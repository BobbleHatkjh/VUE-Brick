(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(20)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 2 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'A',
    props: ['href'],
    data() {
        return {};
    },

    methods: {
        // a标签的跳转功能
        hrefJump() {
            if (this.href !== '' && this.href !== undefined) {
                window.open(this.href, "_blank");
            }
        }

    },

    created() {
        // 主题设置
        // this.Theme = STo.ThemeConfig;

    }

});

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'Button',
    props: ['type'], // primary default danger
    data() {
        return {
            b_type: 'default'
        };
    },

    methods: {
        //
        setType() {
            if (this.type !== undefined && this.type !== '') {
                this.b_type = this.type;
            }
        }
    },

    created() {
        // 设置类型
        this.setType();
    }

});

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__static_up_white_png__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__static_up_white_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__static_up_white_png__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'Footer',
    props: ['logo', 'support', 'trigger', 'footFold', 'themeConfig', 'QRCode', 'grid'],
    data() {
        return {
            footer_trigger_style: { margin: '-60px auto 0 auto', opacity: '' },
            footer_height: { height: '' },
            drop_img: __WEBPACK_IMPORTED_MODULE_0__static_up_white_png___default.a,
            text_word: ''
        };
    },
    methods: {
        footerTrigger() {
            switch (this.trigger) {// 默认居中
                case 'left':
                    this.footer_trigger_style = { margin: '-60px auto 0 0' };
                    break;
                case 'mid':
                    this.footer_trigger_style = { margin: '-60px auto 0 auto' };
                    break;
                case 'right':
                    this.footer_trigger_style = { margin: '-60px 0 0 auto' };
                    break;
                default:
                    break;
            }
            if (!this.footFold) {
                this.footer_height.height = '310px';
            }
        },

        // 改变主题
        themeFun(color) {
            const config_ = window.document.documentElement;
            if (color === 'red') {
                config_.setAttribute('data-theme', 'red');
            } else if (color === 'blue') {
                config_.setAttribute('data-theme', 'blue');
            } else {
                config_.setAttribute('data-theme', 'green');
            }
        },

        hov(from) {
            if (this.footFold) {
                if (from) {
                    this.footer_height.height = '310px';
                    this.footer_trigger_style.opacity = '0';
                } else {
                    this.footer_height.height = '0';
                    this.footer_trigger_style.opacity = '1';
                }
            }
        },

        OutLink(linkUrl) {
            window.open(linkUrl, "_blank");
        }

    },
    created() {
        // this.footer__ = STo[STo.language].footer;
        this.footerTrigger();
    }

});

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'Inclusion',
    props: ['listData', 'gridLine', 'test'],
    data() {
        return {
            Data__: [],
            Grid: true
        };
    },

    methods: {
        // 是否显示边框
        gridSelect() {
            this.test && console.log(this.gridLine);
            if (this.gridLine !== undefined && this.gridLine !== '') {
                this.Grid = this.gridLine;
            }
        },
        // 计算显示内容
        checkData() {
            const allData = [];
            let singleLine = {};
            let listLine = [];

            this.listData.map((item, index) => {
                const supportSingle = {};

                supportSingle.url = item.url;
                supportSingle.logo = item.logo;
                supportSingle.title = item.title;
                supportSingle.introduce = item.introduce;

                listLine.push(supportSingle);

                if (listLine.length === 3 || index === this.listData.length - 1) {
                    singleLine.info = listLine;
                    allData.push(singleLine);
                    listLine = [];
                    singleLine = {};
                }
            });
            this.Data__ = allData;
            this.test && console.log(this.Data__);
        },

        //
        hrefJump(url) {
            window.open(url, "_blank");
        }

    },

    created() {
        this.gridSelect();
        this.checkData();

        // 主题设置
        // this.Theme = STo.ThemeConfig;
    }

});

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'Link',
    // inject: ['ComponentCall'],
    props: ['link__'],
    data() {
        return {
            lan: 'EN'
        };
    },
    methods: {
        // 改变了显示语言
        language() {
            console.log('点击了切换语言');
            // let STo = this.$store.state;
            // switch (STo.language) {
            //     case 'ENG':  // 原先是英文 变成中文
            //         STo.language = 'CHN';
            //         // this.ComponentCall('Tip', { status: 'success', message: '语言已切换至 中文' });
            //         break;
            //     case 'CHN':  // 原先是中文 变成英文
            //         STo.language = 'ENG';
            //         // this.ComponentCall('Tip', { status: 'success', message: 'Language switched to English' });
            //         break;
            // }
        }

    },

    created() {
        // let STo = this.$store.state;
        // if(STo.language === 'CHN'){
        //     console.log('中文');
        //     this.lan = 'EN';
        // } else {
        //     this.lan = '中';
        // }
    }

});

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_swiper__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__static_loader_png__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__static_loader_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__static_loader_png__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["a"] = ({
  name: 'Notice',
  props: ['noticeData', 'trigger', 'test'],
  data() {
    return {
      home_page: {},
      show: false,
      conObj: {
        height: ''
      },
      Loader: __WEBPACK_IMPORTED_MODULE_1__static_loader_png___default.a // 鼠标滑过的动画
    };
  },
  methods: {
    test_() {
      this.test && console.log(this.noticeData);
    }

  },
  mounted() {
    let myRoll = new __WEBPACK_IMPORTED_MODULE_0_swiper__["a" /* default */]('.roll_container_notice', {
      direction: 'vertical',
      mousewheel: true,
      loop: false,
      autoplay: {
        delay: 2500
      },
      pagination: {
        el: '.swiper-pagination'
      }
    });
  },
  created() {
    this.test_();
    // this.noticeTrigger();
  }

});

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return win; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return doc; });
/**
 * SSR Window 1.0.1
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2018, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: July 18, 2018
 */
var doc = (typeof document === 'undefined') ? {
  body: {},
  addEventListener: function addEventListener() {},
  removeEventListener: function removeEventListener() {},
  activeElement: {
    blur: function blur() {},
    nodeName: '',
  },
  querySelector: function querySelector() {
    return null;
  },
  querySelectorAll: function querySelectorAll() {
    return [];
  },
  getElementById: function getElementById() {
    return null;
  },
  createEvent: function createEvent() {
    return {
      initEvent: function initEvent() {},
    };
  },
  createElement: function createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute: function setAttribute() {},
      getElementsByTagName: function getElementsByTagName() {
        return [];
      },
    };
  },
  location: { hash: '' },
} : document; // eslint-disable-line

var win = (typeof window === 'undefined') ? {
  document: doc,
  navigator: {
    userAgent: '',
  },
  location: {},
  history: {},
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener: function addEventListener() {},
  removeEventListener: function removeEventListener() {},
  getComputedStyle: function getComputedStyle() {
    return {
      getPropertyValue: function getPropertyValue() {
        return '';
      },
    };
  },
  Image: function Image() {},
  Date: function Date() {},
  screen: {},
  setTimeout: function setTimeout() {},
  clearTimeout: function clearTimeout() {},
} : window; // eslint-disable-line




/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'PageLabel',
    props: ['avatar'],
    data() {
        return {};
    },

    methods: {},

    created() {

        // 主题设置
        // this.Theme = STo.ThemeConfig;

    }

});

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'TabBar',
    props: ['href'],
    data() {
        return {};
    },

    methods: {
        // a标签的跳转功能
        hrefJump() {
            if (this.href !== '' && this.href !== undefined) {
                window.open(this.href, "_blank");
            }
        }

    },

    created() {
        // 主题设置
        // this.Theme = STo.ThemeConfig;

    }

});

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'Tittle',
    props: ['Img', 'title'],
    data() {
        return {};
    },
    methods: {}

});

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'NaviBar',
    props: ['menuData', 'link', 'test'],
    data() {
        return {
            naviRouter: [], // 路由数据
            select_open: [99, 99] // 打开的位置
        };
    },
    methods: {
        turn(Todo, to, index, indexIn) {
            if (to !== undefined) {
                if (Todo === 'toTurn') {
                    this.test && console.log(`点击跳转到内部链接 ${to}`);
                    this.$emit('return', to); // @return
                } else {
                    // 外部链接
                    window.open(to, "_blank");
                }
            }
            this.select_open = [index, indexIn];
        },

        naviData() {
            // 解析目录
            const routerData = [];
            this.menuData.map(item => {
                const newData = {};
                newData.show_ = false;
                newData.name = item.name;
                if (item.path !== undefined && item.path !== '') {
                    newData.onclick = 'toTurn';
                    newData.To = item.path;
                } else {
                    newData.onclick = 'toOut';
                    newData.To = item.linkUrl;
                }
                newData.lab = [];
                if (item.lab) {
                    item.lab.map(itemIn => {
                        const newDataIn = {};
                        newDataIn.show_ = false;
                        newDataIn.name = itemIn.name;
                        if (itemIn.path !== undefined && itemIn.path !== '') {
                            newDataIn.onclick = 'toTurn';
                            newDataIn.To = itemIn.path;
                        } else {
                            newDataIn.onclick = 'toOut';
                            newDataIn.To = itemIn.linkUrl;
                        }
                        newData.lab.push(newDataIn);
                    });
                }
                routerData.push(newData);
            });
            this.naviRouter = routerData;
            this.test && console.log(routerData);
        }

    },

    created() {
        // 解析目录
        this.naviData();

        // 主题设置
        // this.Theme = STo.ThemeConfig;
    },

    destroyed() {
        this.select_open = [99, 99];
    }

});

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'Dot',
    props: ['fillet', 'backGroundColor'],
    data() {
        return {
            b_dot_style: {
                borderRadius: '100px'
            }
        };
    },
    methods: {
        // 确定主题格式
        filletSelect() {
            if (!this.fillet) {
                this.b_dot_style.borderRadius = '5px';
            }
        },

        // 点击时的回调
        callBack_() {
            this.$emit('return', 'click');
        }

    },
    created() {
        this.filletSelect();
    }

});

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__static_search_white_png__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__static_search_white_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__static_search_white_png__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__static_search_dark_png__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__static_search_dark_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__static_search_dark_png__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["a"] = ({
    name: 'HeadBar',
    props: ['logo', 'name', 'search', 'menuData', 'themeConfig', 'test'],
    data() {
        return {
            router: [],
            head_show: false,
            head_bac: { backgroundColor: 'rgba(255,255,255,0.7)' },
            search_img: __WEBPACK_IMPORTED_MODULE_1__static_search_dark_png___default.a,
            search_word: '',
            search_drop_show: false,
            focus_drop: false,
            theme_show: false
        };
    },

    methods: {
        // 全局监听鼠标点击
        click_() {
            if (!this.focus_drop) {
                this.search_drop_show = false;
                if (this.head_show === false) {
                    this.head_bac = { backgroundColor: 'rgba(255,255,255,0.7)' };
                }
            }
        },

        // 聚焦背景
        bac_(what) {
            if (what === 'in') {
                this.head_show = true;
                this.head_bac = { backgroundColor: 'white' };
            } else {
                this.head_show = false;
                if (!this.search_drop_show) {
                    this.head_bac = { backgroundColor: 'rgba(255,255,255,0.7)' };
                }
            }
        },

        //
        search_drop(what) {
            what === 'in' ? this.focus_drop = true : this.focus_drop = false;
        },

        // 改变搜索颜色
        changeSearchImg(what) {
            if (what === 'in') {
                this.search_img = __WEBPACK_IMPORTED_MODULE_0__static_search_white_png___default.a;
            } else {
                this.search_img = __WEBPACK_IMPORTED_MODULE_1__static_search_dark_png___default.a;
            }
        },

        // 用户点击了选项
        userClick(Todo, to) {
            if (to !== undefined) {
                if (Todo === 'toTurn') {
                    this.test && console.log(`点击跳转到内部链接 ${to}`);
                    this.$emit('return', to); // @return
                } else {
                    // 外部链接
                    window.open(to, "_blank");
                }
            }
        },

        // 改变主题
        themeFun(color) {
            const config_ = window.document.documentElement;
            if (color === 'red') {
                config_.setAttribute('data-theme', 'red');
            } else if (color === 'blue') {
                config_.setAttribute('data-theme', 'blue');
            } else {
                config_.setAttribute('data-theme', 'green');
            }
        },

        // 搜索按钮
        searchButton() {
            this.$emit('search', this.search_word);
            this.search_drop_show = true;
        },

        // 搜索输入框内容
        searchCon(event) {
            this.search_word = event.currentTarget.value;
        },

        // 测试用
        test_() {
            const testData = {
                logo: this.logo,
                name: this.name,
                search: this.search,
                menuData: this.menuData,
                themeConfig: this.themeConfig
            };
            console.log('props' + testData);
        },

        // 计算路由
        menuDataAnalyse() {
            // 解析目录
            const routerData = [];
            this.menuData.map(item => {
                const newData = {};
                newData.show_ = false;
                newData.name = item.name;
                if (item.path !== undefined && item.path !== '') {
                    newData.onclick = 'toTurn';
                    newData.To = item.path;
                } else {
                    newData.onclick = 'toOut';
                    newData.To = item.linkUrl;
                }
                newData.lab = [];
                if (item.lab) {
                    item.lab.map(itemIn => {
                        const newDataIn = {};
                        newDataIn.show_ = false;
                        newDataIn.name = itemIn.name;
                        if (itemIn.path !== undefined && itemIn.path !== '') {
                            newDataIn.onclick = 'toTurn';
                            newDataIn.To = itemIn.path;
                        } else {
                            newDataIn.onclick = 'toOut';
                            newDataIn.To = itemIn.linkUrl;
                        }
                        newData.lab.push(newDataIn);
                    });
                }
                routerData.push(newData);
            });
            this.router = routerData;
            this.test && console.log('路由表' + this.router);
        }

    },

    created() {
        window.addEventListener('click', this.click_);

        // 计算路由
        this.menuDataAnalyse();
        this.test && this.test_();
    }

});

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__components_a_a_vue__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_button_button_vue__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_footer_footer_vue__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_inclusion_inclusion_vue__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_link_link_vue__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__components_notice_notice_vue__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__components_pageLabel_pageLabel_vue__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__components_tabBar_tabBar_vue__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__components_title_title_vue__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__components_naviBar_naviBar_vue__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__components_dot_dot_vue__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__components_headBar_headBar_vue__ = __webpack_require__(70);





// import b_my from './components/my/my.vue'







// import b_tip from './components/tip/tip.vue'


const A = __WEBPACK_IMPORTED_MODULE_0__components_a_a_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["A"] = A;

const Button = __WEBPACK_IMPORTED_MODULE_1__components_button_button_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["Button"] = Button;

const Footer = __WEBPACK_IMPORTED_MODULE_2__components_footer_footer_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["Footer"] = Footer;

const HeadBar = __WEBPACK_IMPORTED_MODULE_11__components_headBar_headBar_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["HeadBar"] = HeadBar;

const Inclusion = __WEBPACK_IMPORTED_MODULE_3__components_inclusion_inclusion_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["Inclusion"] = Inclusion;

const Notice = __WEBPACK_IMPORTED_MODULE_5__components_notice_notice_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["Notice"] = Notice;

const PageLabel = __WEBPACK_IMPORTED_MODULE_6__components_pageLabel_pageLabel_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["PageLabel"] = PageLabel;

const Link = __WEBPACK_IMPORTED_MODULE_4__components_link_link_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["Link"] = Link;

const TabBar = __WEBPACK_IMPORTED_MODULE_7__components_tabBar_tabBar_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["TabBar"] = TabBar;

const Title = __WEBPACK_IMPORTED_MODULE_8__components_title_title_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["Title"] = Title;

// export const My = b_my;
const NaviBar = __WEBPACK_IMPORTED_MODULE_9__components_naviBar_naviBar_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["NaviBar"] = NaviBar;

const Dot = __WEBPACK_IMPORTED_MODULE_10__components_dot_dot_vue__["a" /* default */];
/* harmony export (immutable) */ __webpack_exports__["Dot"] = Dot;


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_a_vue__ = __webpack_require__(3);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0768a25a_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_a_vue__ = __webpack_require__(21);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(18)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_a_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0768a25a_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_a_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/a/a.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0768a25a", Component.options)
  } else {
    hotAPI.reload("data-v-0768a25a", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(19);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("d7b08f64", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-0768a25a\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./a.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-0768a25a\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./a.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.b_a{height:fit-content;width:fit-content;color:#42b983\n}\n[data-theme=\"green\"] .b_a{color:#42b983\n}\n[data-theme=\"red\"] .b_a{color:#fb7299\n}\n[data-theme=\"blue\"] .b_a{color:#1378ff\n}\n.b_a:hover{cursor:pointer;font-weight:bold\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/a/a.vue"],"names":[],"mappings":";AAAA,KAAK,mBAAmB,kBAAkB,aAAa;CAAC;AAAA,0BAA0B,aAAa;CAAC;AAAA,wBAAwB,aAAa;CAAC;AAAA,yBAAyB,aAAa;CAAC;AAAA,WAAW,eAAe,gBAAgB;CAAC","file":"a.vue","sourcesContent":[".b_a{height:fit-content;width:fit-content;color:#42b983}[data-theme=\"green\"] .b_a{color:#42b983}[data-theme=\"red\"] .b_a{color:#fb7299}[data-theme=\"blue\"] .b_a{color:#1378ff}.b_a:hover{cursor:pointer;font-weight:bold}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 20 */
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "b_a",
      attrs: { id: "A" },
      on: {
        click: function($event) {
          return _vm.hrefJump()
        }
      }
    },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-0768a25a", esExports)
  }
}

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue__ = __webpack_require__(4);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3ab8cd62_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_vue__ = __webpack_require__(25);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(23)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_button_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3ab8cd62_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_button_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/button/button.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3ab8cd62", Component.options)
  } else {
    hotAPI.reload("data-v-3ab8cd62", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(24);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("6c5eb324", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3ab8cd62\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./button.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3ab8cd62\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./button.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.b_button_{display:flex;height:fit-content;width:fit-content;min-width:56px;padding:6px 14px;font-size:14px;border-radius:8px;user-select:none\n}\n.b_button_slot{margin:auto\n}\n._primary{color:white;background-color:rgba(66,185,131,0.9)\n}\n[data-theme=\"green\"] ._primary{background-color:rgba(66,185,131,0.9)\n}\n[data-theme=\"red\"] ._primary{background-color:rgba(251,114,153,0.9)\n}\n[data-theme=\"blue\"] ._primary{background-color:rgba(19,120,255,0.9)\n}\n._primary:hover{transition:background-color 100ms, box-shadow 100ms;cursor:pointer;background-color:#42b983;box-shadow:0 0 6px rgba(66,185,131,0.6)\n}\n[data-theme=\"green\"] ._primary:hover{background-color:#42b983\n}\n[data-theme=\"red\"] ._primary:hover{background-color:#fb7299\n}\n[data-theme=\"blue\"] ._primary:hover{background-color:#1378ff\n}\n[data-theme=\"green\"] ._primary:hover{box-shadow:0 0 6px rgba(66,185,131,0.6)\n}\n[data-theme=\"red\"] ._primary:hover{box-shadow:0 0 6px rgba(251,114,153,0.6)\n}\n[data-theme=\"blue\"] ._primary:hover{box-shadow:0 0 6px rgba(19,120,255,0.6)\n}\n._default{color:rgba(0,0,0,0.65);border:1px solid #d2d2d2;background-color:white\n}\n._default:hover{transition:border 100ms, color 100ms, box-shadow 100ms;cursor:pointer;color:#42b983;border:1px solid rgba(66,185,131,0.8);box-shadow:0 0 6px rgba(66,185,131,0.6)\n}\n[data-theme=\"green\"] ._default:hover{color:#42b983\n}\n[data-theme=\"red\"] ._default:hover{color:#fb7299\n}\n[data-theme=\"blue\"] ._default:hover{color:#1378ff\n}\n[data-theme=\"green\"] ._default:hover{border:1px solid rgba(66,185,131,0.8)\n}\n[data-theme=\"red\"] ._default:hover{border:1px solid rgba(251,114,153,0.8)\n}\n[data-theme=\"blue\"] ._default:hover{border:1px solid rgba(19,120,255,0.8)\n}\n[data-theme=\"green\"] ._default:hover{box-shadow:0 0 6px rgba(66,185,131,0.6)\n}\n[data-theme=\"red\"] ._default:hover{box-shadow:0 0 6px rgba(251,114,153,0.6)\n}\n[data-theme=\"blue\"] ._default:hover{box-shadow:0 0 6px rgba(19,120,255,0.6)\n}\n._danger{color:white;background-color:#ff4d4f\n}\n._danger:hover{transition:background-color 100ms, box-shadow 100ms;cursor:pointer;background-color:rgba(255,21,35,0.85);box-shadow:0 0 6px rgba(255,77,79,0.61)\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/button/button.vue"],"names":[],"mappings":";AAAA,WAAW,aAAa,mBAAmB,kBAAkB,eAAe,iBAAiB,eAAe,kBAAkB,gBAAgB;CAAC;AAAA,eAAe,WAAW;CAAC;AAAA,UAAU,YAAY,qCAAqC;CAAC;AAAA,+BAA+B,qCAAqC;CAAC;AAAA,6BAA6B,sCAAsC;CAAC;AAAA,8BAA8B,qCAAqC;CAAC;AAAA,gBAAgB,oDAAoD,eAAe,yBAAyB,uCAAuC;CAAC;AAAA,qCAAqC,wBAAwB;CAAC;AAAA,mCAAmC,wBAAwB;CAAC;AAAA,oCAAoC,wBAAwB;CAAC;AAAA,qCAAqC,uCAAuC;CAAC;AAAA,mCAAmC,wCAAwC;CAAC;AAAA,oCAAoC,uCAAuC;CAAC;AAAA,UAAU,uBAAuB,yBAAyB,sBAAsB;CAAC;AAAA,gBAAgB,uDAAuD,eAAe,cAAc,sCAAsC,uCAAuC;CAAC;AAAA,qCAAqC,aAAa;CAAC;AAAA,mCAAmC,aAAa;CAAC;AAAA,oCAAoC,aAAa;CAAC;AAAA,qCAAqC,qCAAqC;CAAC;AAAA,mCAAmC,sCAAsC;CAAC;AAAA,oCAAoC,qCAAqC;CAAC;AAAA,qCAAqC,uCAAuC;CAAC;AAAA,mCAAmC,wCAAwC;CAAC;AAAA,oCAAoC,uCAAuC;CAAC;AAAA,SAAS,YAAY,wBAAwB;CAAC;AAAA,eAAe,oDAAoD,eAAe,sCAAsC,uCAAuC;CAAC","file":"button.vue","sourcesContent":[".b_button_{display:flex;height:fit-content;width:fit-content;min-width:56px;padding:6px 14px;font-size:14px;border-radius:8px;user-select:none}.b_button_slot{margin:auto}._primary{color:white;background-color:rgba(66,185,131,0.9)}[data-theme=\"green\"] ._primary{background-color:rgba(66,185,131,0.9)}[data-theme=\"red\"] ._primary{background-color:rgba(251,114,153,0.9)}[data-theme=\"blue\"] ._primary{background-color:rgba(19,120,255,0.9)}._primary:hover{transition:background-color 100ms, box-shadow 100ms;cursor:pointer;background-color:#42b983;box-shadow:0 0 6px rgba(66,185,131,0.6)}[data-theme=\"green\"] ._primary:hover{background-color:#42b983}[data-theme=\"red\"] ._primary:hover{background-color:#fb7299}[data-theme=\"blue\"] ._primary:hover{background-color:#1378ff}[data-theme=\"green\"] ._primary:hover{box-shadow:0 0 6px rgba(66,185,131,0.6)}[data-theme=\"red\"] ._primary:hover{box-shadow:0 0 6px rgba(251,114,153,0.6)}[data-theme=\"blue\"] ._primary:hover{box-shadow:0 0 6px rgba(19,120,255,0.6)}._default{color:rgba(0,0,0,0.65);border:1px solid #d2d2d2;background-color:white}._default:hover{transition:border 100ms, color 100ms, box-shadow 100ms;cursor:pointer;color:#42b983;border:1px solid rgba(66,185,131,0.8);box-shadow:0 0 6px rgba(66,185,131,0.6)}[data-theme=\"green\"] ._default:hover{color:#42b983}[data-theme=\"red\"] ._default:hover{color:#fb7299}[data-theme=\"blue\"] ._default:hover{color:#1378ff}[data-theme=\"green\"] ._default:hover{border:1px solid rgba(66,185,131,0.8)}[data-theme=\"red\"] ._default:hover{border:1px solid rgba(251,114,153,0.8)}[data-theme=\"blue\"] ._default:hover{border:1px solid rgba(19,120,255,0.8)}[data-theme=\"green\"] ._default:hover{box-shadow:0 0 6px rgba(66,185,131,0.6)}[data-theme=\"red\"] ._default:hover{box-shadow:0 0 6px rgba(251,114,153,0.6)}[data-theme=\"blue\"] ._default:hover{box-shadow:0 0 6px rgba(19,120,255,0.6)}._danger{color:white;background-color:#ff4d4f}._danger:hover{transition:background-color 100ms, box-shadow 100ms;cursor:pointer;background-color:rgba(255,21,35,0.85);box-shadow:0 0 6px rgba(255,77,79,0.61)}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _vm.b_type === "primary"
      ? _c(
          "div",
          { staticClass: "b_button_ _primary", attrs: { id: "Button_p" } },
          [_c("div", { staticClass: "b_button_slot" }, [_vm._t("default")], 2)]
        )
      : _vm._e(),
    _vm._v(" "),
    _vm.b_type === "default"
      ? _c(
          "div",
          { staticClass: "b_button_ _default", attrs: { id: "Button_def" } },
          [_c("div", { staticClass: "b_button_slot" }, [_vm._t("default")], 2)]
        )
      : _vm._e(),
    _vm._v(" "),
    _vm.b_type === "danger"
      ? _c(
          "div",
          { staticClass: "b_button_ _danger", attrs: { id: "Button_dan" } },
          [_c("div", { staticClass: "b_button_slot" }, [_vm._t("default")], 2)]
        )
      : _vm._e()
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-3ab8cd62", esExports)
  }
}

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_footer_vue__ = __webpack_require__(5);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_278c512f_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_footer_vue__ = __webpack_require__(30);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(27)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_footer_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_278c512f_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_footer_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/footer/footer.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-278c512f", Component.options)
  } else {
    hotAPI.reload("data-v-278c512f", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(28);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("20abf934", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-278c512f\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./footer.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-278c512f\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./footer.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.mar{margin:auto\n}\n.grid{background-color:rgba(0,0,0,0.6);box-shadow:0 0 15px rgba(0,0,0,0.5)\n}\n.up{display:flex;height:60px;width:120px;border-top-right-radius:10px;border-top-left-radius:10px;transition:opacity 300ms;background-color:rgba(0,0,0,0.5)\n}\n.up_img{height:80px;width:80px;margin:-8px auto 0 auto\n}\n.foot{position:fixed;z-index:99;bottom:0;height:0;width:100%;padding-top:1px;background-color:rgba(0,0,0,0.6);transition:height 300ms\n}\n.foot_unfold{width:100%;padding-top:1px;background-color:rgba(0,0,0,0.6);transition:height 300ms\n}\n.foot_con{display:flex;height:200px;width:1024px;margin:30px auto 0 auto\n}\n.supplier{display:flex;height:30px;width:1024px;z-index:-0;margin:24px auto 0 auto\n}\n.foot_logo{display:flex;height:200px;width:300px;margin:0 0 0 auto;border-right:2px solid white\n}\n.foot_img{height:78%;width:auto;max-width:95%;margin:auto auto auto 0\n}\n.foot_list{display:flex;height:200px;width:950px;padding-left:6px;margin:0 auto 0 0;color:white\n}\n.foot_list_frame{height:200px;width:150px;margin:0 10px auto 0;border-radius:12px\n}\n.foot_list_frame_theme{height:170px\n}\n.foot_input_frame{display:flex;height:200px;width:600px;margin:auto 0\n}\n.foot_input_div{display:block;height:100%;width:600px\n}\n.foot_input_textarea{height:172px;width:552px;margin:0 auto auto 8px;padding:14px;color:white;border:none;font-size:16px;outline:none;border-radius:12px;resize:none\n}\n.foot_list_frame_div{display:flex;height:40px;width:100%;font-weight:bolder;font-size:16px;margin:0 auto;border-radius:12px\n}\n.qr_code{display:flex;height:150px;width:100%;margin:0 auto\n}\n.qr_code_img{margin:auto;height:81%;width:81%\n}\n.QRCode_img_theme{margin:0 auto auto auto;height:74%;width:74%\n}\n.theme_drop{display:block;position:relative;height:25px;width:150px;margin:-15px auto auto auto;text-align:center;border-radius:12px;z-index:100;background-color:rgba(0,0,0,0.6);box-shadow:0 0 15px rgba(0,0,0,0.6);overflow:hidden\n}\n.theme_drop:hover{cursor:pointer;transition:height 200ms;height:80px\n}\n.grid_drop{width:120px\n}\n.theme_drop_title{height:11px;width:88.6%;margin:7px auto;border-radius:12px;background-color:rgba(66,185,131,0.8)\n}\n[data-theme=\"green\"] .theme_drop_title{background-color:rgba(66,185,131,0.8)\n}\n[data-theme=\"red\"] .theme_drop_title{background-color:rgba(251,114,153,0.8)\n}\n[data-theme=\"blue\"] .theme_drop_title{background-color:rgba(19,120,255,0.8)\n}\n.theme_drop_title:hover{cursor:default\n}\n.theme_drop_color{display:flex;height:38px;width:88.6%;margin:16px auto 0 auto\n}\n.theme_drop_green{height:100%;width:30%;margin:0 auto 0 0;border-radius:6px;background-color:#42b983\n}\n.theme_drop_blue{height:100%;width:30%;margin:0 auto;border-radius:6px;background-color:#1378ff\n}\n.theme_drop_red{height:100%;width:30%;margin:0 0 0 auto;border-radius:6px;background-color:#fb7299\n}\n.supplier_text{display:flex;height:100%;width:65px;margin:auto 14px auto 10px;font-size:14px;font-weight:bolder;color:white\n}\n.tou_wei{display:flex;height:80%;margin:auto 7px;font-size:16px;font-weight:bolder;color:white\n}\n.support{text-decoration:none;color:white\n}\n.supplier_link{display:flex;height:32px;width:80px;padding-left:5px;margin:-2px 105px auto auto;border-radius:12px;background-color:rgba(0,0,0,0.5);box-shadow:0 0 20px rgba(0,0,0,0.6)\n}\n.link_drop{display:block;height:20px;width:50px;background-color:#66ccff\n}\n.support:hover{cursor:pointer;color:#42b983\n}\n[data-theme=\"green\"] .support:hover{color:#42b983\n}\n[data-theme=\"red\"] .support:hover{color:#fb7299\n}\n[data-theme=\"blue\"] .support:hover{color:#1378ff\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/footer/footer.vue"],"names":[],"mappings":";AAAA,KAAK,WAAW;CAAC;AAAA,MAAM,iCAAiC,mCAAmC;CAAC;AAAA,IAAI,aAAa,YAAY,YAAY,6BAA6B,4BAA4B,yBAAyB,gCAAgC;CAAC;AAAA,QAAQ,YAAY,WAAW,uBAAuB;CAAC;AAAA,MAAM,eAAe,WAAW,SAAS,SAAS,WAAW,gBAAgB,iCAAiC,uBAAuB;CAAC;AAAA,aAAa,WAAW,gBAAgB,iCAAiC,uBAAuB;CAAC;AAAA,UAAU,aAAa,aAAa,aAAa,uBAAuB;CAAC;AAAA,UAAU,aAAa,YAAY,aAAa,WAAW,uBAAuB;CAAC;AAAA,WAAW,aAAa,aAAa,YAAY,kBAAkB,4BAA4B;CAAC;AAAA,UAAU,WAAW,WAAW,cAAc,uBAAuB;CAAC;AAAA,WAAW,aAAa,aAAa,YAAY,iBAAiB,kBAAkB,WAAW;CAAC;AAAA,iBAAiB,aAAa,YAAY,qBAAqB,kBAAkB;CAAC;AAAA,uBAAuB,YAAY;CAAC;AAAA,kBAAkB,aAAa,aAAa,YAAY,aAAa;CAAC;AAAA,gBAAgB,cAAc,YAAY,WAAW;CAAC;AAAA,qBAAqB,aAAa,YAAY,uBAAuB,aAAa,YAAY,YAAY,eAAe,aAAa,mBAAmB,WAAW;CAAC;AAAA,qBAAqB,aAAa,YAAY,WAAW,mBAAmB,eAAe,cAAc,kBAAkB;CAAC;AAAA,SAAS,aAAa,aAAa,WAAW,aAAa;CAAC;AAAA,aAAa,YAAY,WAAW,SAAS;CAAC;AAAA,kBAAkB,wBAAwB,WAAW,SAAS;CAAC;AAAA,YAAY,cAAc,kBAAkB,YAAY,YAAY,4BAA4B,kBAAkB,mBAAmB,YAAY,iCAAiC,oCAAoC,eAAe;CAAC;AAAA,kBAAkB,eAAe,wBAAwB,WAAW;CAAC;AAAA,WAAW,WAAW;CAAC;AAAA,kBAAkB,YAAY,YAAY,gBAAgB,mBAAmB,qCAAqC;CAAC;AAAA,uCAAuC,qCAAqC;CAAC;AAAA,qCAAqC,sCAAsC;CAAC;AAAA,sCAAsC,qCAAqC;CAAC;AAAA,wBAAwB,cAAc;CAAC;AAAA,kBAAkB,aAAa,YAAY,YAAY,uBAAuB;CAAC;AAAA,kBAAkB,YAAY,UAAU,kBAAkB,kBAAkB,wBAAwB;CAAC;AAAA,iBAAiB,YAAY,UAAU,cAAc,kBAAkB,wBAAwB;CAAC;AAAA,gBAAgB,YAAY,UAAU,kBAAkB,kBAAkB,wBAAwB;CAAC;AAAA,eAAe,aAAa,YAAY,WAAW,2BAA2B,eAAe,mBAAmB,WAAW;CAAC;AAAA,SAAS,aAAa,WAAW,gBAAgB,eAAe,mBAAmB,WAAW;CAAC;AAAA,SAAS,qBAAqB,WAAW;CAAC;AAAA,eAAe,aAAa,YAAY,WAAW,iBAAiB,4BAA4B,mBAAmB,iCAAiC,mCAAmC;CAAC;AAAA,WAAW,cAAc,YAAY,WAAW,wBAAwB;CAAC;AAAA,eAAe,eAAe,aAAa;CAAC;AAAA,oCAAoC,aAAa;CAAC;AAAA,kCAAkC,aAAa;CAAC;AAAA,mCAAmC,aAAa;CAAC","file":"footer.vue","sourcesContent":[".mar{margin:auto}.grid{background-color:rgba(0,0,0,0.6);box-shadow:0 0 15px rgba(0,0,0,0.5)}.up{display:flex;height:60px;width:120px;border-top-right-radius:10px;border-top-left-radius:10px;transition:opacity 300ms;background-color:rgba(0,0,0,0.5)}.up_img{height:80px;width:80px;margin:-8px auto 0 auto}.foot{position:fixed;z-index:99;bottom:0;height:0;width:100%;padding-top:1px;background-color:rgba(0,0,0,0.6);transition:height 300ms}.foot_unfold{width:100%;padding-top:1px;background-color:rgba(0,0,0,0.6);transition:height 300ms}.foot_con{display:flex;height:200px;width:1024px;margin:30px auto 0 auto}.supplier{display:flex;height:30px;width:1024px;z-index:-0;margin:24px auto 0 auto}.foot_logo{display:flex;height:200px;width:300px;margin:0 0 0 auto;border-right:2px solid white}.foot_img{height:78%;width:auto;max-width:95%;margin:auto auto auto 0}.foot_list{display:flex;height:200px;width:950px;padding-left:6px;margin:0 auto 0 0;color:white}.foot_list_frame{height:200px;width:150px;margin:0 10px auto 0;border-radius:12px}.foot_list_frame_theme{height:170px}.foot_input_frame{display:flex;height:200px;width:600px;margin:auto 0}.foot_input_div{display:block;height:100%;width:600px}.foot_input_textarea{height:172px;width:552px;margin:0 auto auto 8px;padding:14px;color:white;border:none;font-size:16px;outline:none;border-radius:12px;resize:none}.foot_list_frame_div{display:flex;height:40px;width:100%;font-weight:bolder;font-size:16px;margin:0 auto;border-radius:12px}.qr_code{display:flex;height:150px;width:100%;margin:0 auto}.qr_code_img{margin:auto;height:81%;width:81%}.QRCode_img_theme{margin:0 auto auto auto;height:74%;width:74%}.theme_drop{display:block;position:relative;height:25px;width:150px;margin:-15px auto auto auto;text-align:center;border-radius:12px;z-index:100;background-color:rgba(0,0,0,0.6);box-shadow:0 0 15px rgba(0,0,0,0.6);overflow:hidden}.theme_drop:hover{cursor:pointer;transition:height 200ms;height:80px}.grid_drop{width:120px}.theme_drop_title{height:11px;width:88.6%;margin:7px auto;border-radius:12px;background-color:rgba(66,185,131,0.8)}[data-theme=\"green\"] .theme_drop_title{background-color:rgba(66,185,131,0.8)}[data-theme=\"red\"] .theme_drop_title{background-color:rgba(251,114,153,0.8)}[data-theme=\"blue\"] .theme_drop_title{background-color:rgba(19,120,255,0.8)}.theme_drop_title:hover{cursor:default}.theme_drop_color{display:flex;height:38px;width:88.6%;margin:16px auto 0 auto}.theme_drop_green{height:100%;width:30%;margin:0 auto 0 0;border-radius:6px;background-color:#42b983}.theme_drop_blue{height:100%;width:30%;margin:0 auto;border-radius:6px;background-color:#1378ff}.theme_drop_red{height:100%;width:30%;margin:0 0 0 auto;border-radius:6px;background-color:#fb7299}.supplier_text{display:flex;height:100%;width:65px;margin:auto 14px auto 10px;font-size:14px;font-weight:bolder;color:white}.tou_wei{display:flex;height:80%;margin:auto 7px;font-size:16px;font-weight:bolder;color:white}.support{text-decoration:none;color:white}.supplier_link{display:flex;height:32px;width:80px;padding-left:5px;margin:-2px 105px auto auto;border-radius:12px;background-color:rgba(0,0,0,0.5);box-shadow:0 0 20px rgba(0,0,0,0.6)}.link_drop{display:block;height:20px;width:50px;background-color:#66ccff}.support:hover{cursor:pointer;color:#42b983}[data-theme=\"green\"] .support:hover{color:#42b983}[data-theme=\"red\"] .support:hover{color:#fb7299}[data-theme=\"blue\"] .support:hover{color:#1378ff}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIEAYAAAD9yHLdAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAASAAAAEgARslrPgAABm9JREFUeNrt2z2LFVcAx+GZFTQYCPiGQsogAcHGQhAFJQqCpM1HiIWkMKSwtvets1FQ8DsEIlZWQQtXRJRUKYLBt6CGJIXeSfFnE9a7u951790zL8/THGYVnDlzzvnlcjdVBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAn1aVvAEpomqZpmi++yNXXX2c8fDjjrl0ZP/+8aqqmajZvruqqruqnT3P9+++5fvQo1z/+mOtbt+q6ruv6779LPx8Aa9SMmlEz2rgxwTh5MuODB81M/PVXxhs38u/u3Vv6+QFYpRzkX32V8fHj2QTjQ96+zXj5coLy2Wel5wWA9+SgruuMZ89mfPeuTDiW88svPpkAtEQO5rm5HMxXr5ZOxGT++CPjwYOl5w9gcP4LR9M0TXPtWukkrNqoGTWjP//MxZEjpecToPc6Hw4hAVhfvQuHkADMVu/DISQA0zW4cAgJwNoMPhzvExKAleWAFI5lCQnAYjkQhWNiQgIMXQ5A4fhoQgIMTQ68hXBcv176HF75gD53LuM33+SHDx+Wvq2lvXmT+zx0qPT7BZi6HHRd+cRx5szY/Y+aUTPasSN/fv9+6Tsc4xMJ0Dc50LobjrHnERKA2coB1p9wjD2fkABMVw6s/oZj7HmFBGBtckANJxxjzy8kAKuTA2m44RibDyEBWFkOIOFYdn6EBGCxHDjCMfF8CQkwdDlghOOj509IgKHJgSIcU5tPIQH6LgeIcMxsfoUE6JscGMKxbvMtJEDX5YAQjmLzLyRA1+RAEI62EBKg9XIACEdbCQnQOtnwwtEVQgIUlw0uHF0lJMC6y4YWjr4QEmDmsoGFo6+EBJi6bFjhGAohAdYsG1Q4hmpxSObnS7/hMUIC7ZMNKRyEkAAflA0oHCxNSIAx2XDCwWSEBBAO1kRIYICyoYSD6RASGIBsIOFgNoQEeigbRjhYH0ICPZANIhyUkfe6ZUvGu3dLr7AxQgLjsiGEg3bIexYSaLVsAOGgnfLehQRaJQteOOiGrAMhgaKywIWDbsq6EBJYV1nQwkE/ZJ0ICcxUFrBw0E9ZN0ICU5UFKxwMQ9aRkMCaZIEKB8OUdSUksCpZkMIBVSUkMJEsQOGApWTdCQkskgUnHDCJrEMhYeCywIQDPkbWpZAwMFlQwgHTkHUqJPRcFpBwwCxk3QoJPZMFIxywHrKOhYSOywIRDigh61pI6JgsCOGANsg6FxJaLgtAOKCNsu6FhJbJCxcO6ILsAyGhsLxg4YAuyr4QEtZZXqhwQB9knwgJM5YXKBzQR9k3QsKU5YUJBwxB9pGQsEZ5QcIBQ5R9JSSsUl6IcABCwoTyAoQDGJd9JyS8JxMuHMCHZR8KyeBlgoUDWL3sSyEZrEzw1aul3/PKTp8uPU/A8nKObN+e/XrvXukTY2lv3uQ+9+8vPV+dt3Awl36lKxMO6JJuhOS33xbus/R8dU4mcNu2jK9elX6VSxMO6LLWh2TUjJrR+fOl56lzMnHfflv6/S3NdxzQJ9nXW7bk3Llzp/QJs9jz5xk3bCg9T53Rzu88fOKAPmv3J5Ivvyw9P++bK30Dy6qruqq3bSt9G/H993Vd13V96VLpOwFmp56r5+q558+rpmqq5tix/HR+vvR9Rfu+C2lvQKqqqqqXL8v++8IBQ9TOkLx4UXpeOiMf2U6eLPNR0XccwP9yLpT6juTFi4y+A5lYJmzht7Bev16fF+U7DmB5Zb4juXix9HN3Vibwhx+EA2iLnBsL/4E7q5A8eZJg7dhR+nk7KxNZ1xmvXJnOi3n7Ni/mu+9KPx/QXYtD8vPP0zmfXr7MeOBA6efrnUzsqVMJwLNnq3sxDx9mPHq09HMA/ZFz5ZNPci5duJDrf/6Z+GgaNaNm9NNPGXfvLv08k6pL38DHyqx/+mmujh/PuG9fxq1bMz55kvH27YUxv1X17l3p+wf6KyHYuTP/O8KJE/ltrj17cr1pU/7Wr7/m5zdv5re+7t8vfd8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADL+xfgWju1ea2tFgAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxOS0wMy0yMVQxNTo0MTo1OSswODowMMrns3EAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTktMDMtMjFUMTU6NDE6NTkrMDg6MDC7ugvNAAAAUHRFWHRzdmc6YmFzZS11cmkAZmlsZTovLy9ob21lL2FkbWluL2ljb24tZm9udC90bXAvaWNvbl8xZ3U2NWZscmJzNi9zaGFuZ2ppYW50b3UxLnN2Z2WisbAAAAAASUVORK5CYII="

/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      ref: "foot",
      class: _vm.footFold ? "foot" : "foot_unfold",
      style: _vm.footer_height,
      on: {
        mouseover: function($event) {
          return _vm.hov(1)
        },
        mouseout: function($event) {
          return _vm.hov(0)
        }
      }
    },
    [
      _vm.footFold
        ? _c("div", { staticClass: "up", style: _vm.footer_trigger_style }, [
            _c("img", {
              staticClass: "up_img",
              attrs: { src: _vm.drop_img, alt: "up" }
            })
          ])
        : _vm._e(),
      _vm._v(" "),
      _c("div", { staticClass: "foot_con" }, [
        _c("div", { staticClass: "foot_logo" }, [
          _c("img", {
            staticClass: "foot_img",
            attrs: { src: _vm.logo, alt: "logo", draggable: "false" }
          })
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "foot_list" }, [
          _c("div", { staticClass: "foot_input_frame" }, [
            _c("div", { staticClass: "foot_input_div" }, [
              _c(
                "div",
                {
                  staticClass: "foot_input_textarea",
                  class: _vm.grid && "grid",
                  model: {
                    value: _vm.text_word,
                    callback: function($$v) {
                      _vm.text_word = $$v
                    },
                    expression: "text_word"
                  }
                },
                [_vm._t("default")],
                2
              )
            ])
          ]),
          _vm._v(" "),
          _c(
            "div",
            {
              staticClass: "foot_list_frame",
              class: [
                _vm.themeConfig && "foot_list_frame_theme",
                _vm.grid && "grid"
              ]
            },
            [
              _vm._m(0),
              _vm._v(" "),
              _c("div", { staticClass: "qr_code" }, [
                _c("img", {
                  staticClass: "qr_code_img",
                  class: _vm.themeConfig && "QRCode_img_theme",
                  attrs: { src: _vm.QRCode, alt: "QR_code", draggable: "false" }
                })
              ]),
              _vm._v(" "),
              _vm.themeConfig
                ? _c(
                    "div",
                    {
                      staticClass: "theme_drop",
                      class: !_vm.grid && "grid_drop"
                    },
                    [
                      _c("div", { staticClass: "theme_drop_title" }),
                      _vm._v(" "),
                      _c("div", { staticClass: "theme_drop_color" }, [
                        _c("div", {
                          staticClass: "theme_drop_green",
                          on: {
                            click: function($event) {
                              return _vm.themeFun("green")
                            }
                          }
                        }),
                        _vm._v(" "),
                        _c("div", {
                          staticClass: "theme_drop_blue",
                          on: {
                            click: function($event) {
                              return _vm.themeFun("blue")
                            }
                          }
                        }),
                        _vm._v(" "),
                        _c("div", {
                          staticClass: "theme_drop_red",
                          on: {
                            click: function($event) {
                              return _vm.themeFun("red")
                            }
                          }
                        })
                      ])
                    ]
                  )
                : _vm._e()
            ]
          )
        ])
      ]),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "supplier" },
        [
          _vm._m(1),
          _vm._v(" "),
          _vm._l(_vm.support, function(value) {
            return _c("div", { key: value.name, staticClass: "tou_wei" }, [
              _c(
                "a",
                {
                  staticClass: "mar support",
                  on: {
                    click: function($event) {
                      return _vm.OutLink(value.link)
                    }
                  }
                },
                [_vm._v(_vm._s(value.name))]
              )
            ])
          })
        ],
        2
      )
    ]
  )
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "foot_list_frame_div" }, [
      _c("a", { staticClass: "mar" }, [_vm._v("联系我们")])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "supplier_text" }, [
      _c("a", { staticClass: "mar" }, [_vm._v("合作链接")])
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-278c512f", esExports)
  }
}

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_inclusion_vue__ = __webpack_require__(6);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0d0de589_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_inclusion_vue__ = __webpack_require__(34);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(32)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_inclusion_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0d0de589_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_inclusion_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/inclusion/inclusion.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0d0de589", Component.options)
  } else {
    hotAPI.reload("data-v-0d0de589", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(33);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("75981788", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-0d0de589\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./inclusion.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-0d0de589\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./inclusion.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.b_inclusion{display:block;height:100%;width:100%;margin:auto;padding:0\n}\n.b_inclusion_line_frame{display:flex;height:230px;width:100%\n}\n.b_inclusion_con_frame{display:block;height:90%;width:32%;margin:auto;border-radius:8px;overflow:hidden\n}\n.b_inclusion_con_frame:hover{cursor:pointer;background-color:rgba(66,185,131,0.2);box-shadow:0 0 10px rgba(66,185,131,0.2)\n}\n[data-theme=\"green\"] .b_inclusion_con_frame:hover{background-color:rgba(66,185,131,0.2)\n}\n[data-theme=\"red\"] .b_inclusion_con_frame:hover{background-color:rgba(251,114,153,0.2)\n}\n[data-theme=\"blue\"] .b_inclusion_con_frame:hover{background-color:rgba(19,120,255,0.2)\n}\n[data-theme=\"green\"] .b_inclusion_con_frame:hover{box-shadow:0 0 10px rgba(66,185,131,0.2)\n}\n[data-theme=\"red\"] .b_inclusion_con_frame:hover{box-shadow:0 0 10px rgba(251,114,153,0.2)\n}\n[data-theme=\"blue\"] .b_inclusion_con_frame:hover{box-shadow:0 0 10px rgba(19,120,255,0.2)\n}\n.b_inclusion_con_logo{display:flex;height:40%;width:100%\n}\n.b_inclusion_con_logo_img{display:flex;height:55px;width:100%;overflow:hidden;margin:auto auto 10px auto\n}\n.b_inclusion_con_logo_img img{height:100%;width:auto;margin:auto\n}\n.b_inclusion_con_title{display:flex;height:16%;width:100%\n}\n.b_inclusion_con_title a{margin:0 auto;font-size:20px;font-weight:bolder\n}\n.b_inclusion_con_introduce{display:flex;height:32%;width:80%;margin:1% auto auto auto\n}\n.b_inclusion_con_introduce a{color:#878787;display:-webkit-box;text-overflow:ellipsis;-webkit-box-orient:vertical;-webkit-line-clamp:3;word-break:break-all;overflow:hidden\n}\n.line_vertical{height:50%;width:0;margin:auto;border-right:1px solid rgba(66,185,131,0.7)\n}\n[data-theme=\"green\"] .line_vertical{border-right:1px solid rgba(66,185,131,0.7)\n}\n[data-theme=\"red\"] .line_vertical{border-right:1px solid rgba(251,114,153,0.7)\n}\n[data-theme=\"blue\"] .line_vertical{border-right:1px solid rgba(19,120,255,0.7)\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/inclusion/inclusion.vue"],"names":[],"mappings":";AAAA,aAAa,cAAc,YAAY,WAAW,YAAY,SAAS;CAAC;AAAA,wBAAwB,aAAa,aAAa,UAAU;CAAC;AAAA,uBAAuB,cAAc,WAAW,UAAU,YAAY,kBAAkB,eAAe;CAAC;AAAA,6BAA6B,eAAe,sCAAsC,wCAAwC;CAAC;AAAA,kDAAkD,qCAAqC;CAAC;AAAA,gDAAgD,sCAAsC;CAAC;AAAA,iDAAiD,qCAAqC;CAAC;AAAA,kDAAkD,wCAAwC;CAAC;AAAA,gDAAgD,yCAAyC;CAAC;AAAA,iDAAiD,wCAAwC;CAAC;AAAA,sBAAsB,aAAa,WAAW,UAAU;CAAC;AAAA,0BAA0B,aAAa,YAAY,WAAW,gBAAgB,0BAA0B;CAAC;AAAA,8BAA8B,YAAY,WAAW,WAAW;CAAC;AAAA,uBAAuB,aAAa,WAAW,UAAU;CAAC;AAAA,yBAAyB,cAAc,eAAe,kBAAkB;CAAC;AAAA,2BAA2B,aAAa,WAAW,UAAU,wBAAwB;CAAC;AAAA,6BAA6B,cAAc,oBAAoB,uBAAuB,4BAA4B,qBAAqB,qBAAqB,eAAe;CAAC;AAAA,eAAe,WAAW,QAAQ,YAAY,2CAA2C;CAAC;AAAA,oCAAoC,2CAA2C;CAAC;AAAA,kCAAkC,4CAA4C;CAAC;AAAA,mCAAmC,2CAA2C;CAAC","file":"inclusion.vue","sourcesContent":[".b_inclusion{display:block;height:100%;width:100%;margin:auto;padding:0}.b_inclusion_line_frame{display:flex;height:230px;width:100%}.b_inclusion_con_frame{display:block;height:90%;width:32%;margin:auto;border-radius:8px;overflow:hidden}.b_inclusion_con_frame:hover{cursor:pointer;background-color:rgba(66,185,131,0.2);box-shadow:0 0 10px rgba(66,185,131,0.2)}[data-theme=\"green\"] .b_inclusion_con_frame:hover{background-color:rgba(66,185,131,0.2)}[data-theme=\"red\"] .b_inclusion_con_frame:hover{background-color:rgba(251,114,153,0.2)}[data-theme=\"blue\"] .b_inclusion_con_frame:hover{background-color:rgba(19,120,255,0.2)}[data-theme=\"green\"] .b_inclusion_con_frame:hover{box-shadow:0 0 10px rgba(66,185,131,0.2)}[data-theme=\"red\"] .b_inclusion_con_frame:hover{box-shadow:0 0 10px rgba(251,114,153,0.2)}[data-theme=\"blue\"] .b_inclusion_con_frame:hover{box-shadow:0 0 10px rgba(19,120,255,0.2)}.b_inclusion_con_logo{display:flex;height:40%;width:100%}.b_inclusion_con_logo_img{display:flex;height:55px;width:100%;overflow:hidden;margin:auto auto 10px auto}.b_inclusion_con_logo_img img{height:100%;width:auto;margin:auto}.b_inclusion_con_title{display:flex;height:16%;width:100%}.b_inclusion_con_title a{margin:0 auto;font-size:20px;font-weight:bolder}.b_inclusion_con_introduce{display:flex;height:32%;width:80%;margin:1% auto auto auto}.b_inclusion_con_introduce a{color:#878787;display:-webkit-box;text-overflow:ellipsis;-webkit-box-orient:vertical;-webkit-line-clamp:3;word-break:break-all;overflow:hidden}.line_vertical{height:50%;width:0;margin:auto;border-right:1px solid rgba(66,185,131,0.7)}[data-theme=\"green\"] .line_vertical{border-right:1px solid rgba(66,185,131,0.7)}[data-theme=\"red\"] .line_vertical{border-right:1px solid rgba(251,114,153,0.7)}[data-theme=\"blue\"] .line_vertical{border-right:1px solid rgba(19,120,255,0.7)}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "b_inclusion", attrs: { id: "Inclusion" } },
    _vm._l(_vm.Data__, function(value, index) {
      return _c("div", { staticClass: "b_inclusion_line_frame" }, [
        _c(
          "div",
          {
            staticClass: "b_inclusion_con_frame",
            on: {
              click: function($event) {
                return _vm.hrefJump(value.info[0].url)
              }
            }
          },
          [
            _c("div", { staticClass: "b_inclusion_con_logo" }, [
              _c("div", { staticClass: "b_inclusion_con_logo_img" }, [
                _c("img", { attrs: { src: value.info[0].logo, alt: "" } })
              ])
            ]),
            _vm._v(" "),
            _c("div", { staticClass: "b_inclusion_con_title" }, [
              _c("a", [_vm._v(_vm._s(value.info[0].title))])
            ]),
            _vm._v(" "),
            _c("div", { staticClass: "b_inclusion_con_introduce" }, [
              _c("a", [_vm._v(_vm._s(value.info[0].introduce))])
            ])
          ]
        ),
        _vm._v(" "),
        value.info.length > 1 && _vm.Grid
          ? _c("div", { staticClass: "line_vertical" })
          : _vm._e(),
        _vm._v(" "),
        value.info.length > 1
          ? _c(
              "div",
              {
                staticClass: "b_inclusion_con_frame",
                on: {
                  click: function($event) {
                    return _vm.hrefJump(value.info[1].url)
                  }
                }
              },
              [
                _c("div", { staticClass: "b_inclusion_con_logo" }, [
                  _c("div", { staticClass: "b_inclusion_con_logo_img" }, [
                    _c("img", { attrs: { src: value.info[1].logo, alt: "" } })
                  ])
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "b_inclusion_con_title" }, [
                  _c("a", [_vm._v(_vm._s(value.info[1].title))])
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "b_inclusion_con_introduce" }, [
                  _c("a", [_vm._v(_vm._s(value.info[1].introduce))])
                ])
              ]
            )
          : _vm._e(),
        _vm._v(" "),
        value.info.length > 2 && _vm.Grid
          ? _c("div", { staticClass: "line_vertical" })
          : _vm._e(),
        _vm._v(" "),
        value.info.length > 2
          ? _c(
              "div",
              {
                staticClass: "b_inclusion_con_frame",
                on: {
                  click: function($event) {
                    return _vm.hrefJump(value.info[2].url)
                  }
                }
              },
              [
                _c("div", { staticClass: "b_inclusion_con_logo" }, [
                  _c("div", { staticClass: "b_inclusion_con_logo_img" }, [
                    _c("img", { attrs: { src: value.info[2].logo, alt: "" } })
                  ])
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "b_inclusion_con_title" }, [
                  _c("a", [_vm._v(_vm._s(value.info[2].title))])
                ]),
                _vm._v(" "),
                _c("div", { staticClass: "b_inclusion_con_introduce" }, [
                  _c("a", [_vm._v(_vm._s(value.info[2].introduce))])
                ])
              ]
            )
          : _vm._e()
      ])
    }),
    0
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-0d0de589", esExports)
  }
}

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_link_vue__ = __webpack_require__(7);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0074f58f_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_link_vue__ = __webpack_require__(38);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(36)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_link_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0074f58f_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_link_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/link/link.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0074f58f", Component.options)
  } else {
    hotAPI.reload("data-v-0074f58f", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(37);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("5b09702d", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-0074f58f\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./link.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-0074f58f\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./link.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.mar{margin:auto\n}\n.link_bac{display:flex;height:40px;width:120px;margin:auto 0\n}\n.qub{display:flex;height:30px;width:30px;margin:auto 3px;background-color:rgba(0,0,0,0.4);border-radius:8px\n}\n.qub:hover{cursor:pointer;background-color:rgba(66,185,131,0.8);box-shadow:0 0 10px rgba(66,185,131,0.6)\n}\n.qub_2{display:flex;height:30px;width:30px;margin:auto 5px auto 3px;color:black;font-weight:bolder;font-size:14px;border-radius:8px;background-color:#ffffff\n}\n.qub_2:hover{color:#42b983;cursor:pointer;box-shadow:0 0 10px rgba(255,255,255,0.3)\n}\n.qub_img{height:90%;width:90%;margin:auto\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/link/link.vue"],"names":[],"mappings":";AAAA,KAAK,WAAW;CAAC;AAAA,UAAU,aAAa,YAAY,YAAY,aAAa;CAAC;AAAA,KAAK,aAAa,YAAY,WAAW,gBAAgB,iCAAiC,iBAAiB;CAAC;AAAA,WAAW,eAAe,sCAAsC,wCAAwC;CAAC;AAAA,OAAO,aAAa,YAAY,WAAW,yBAAyB,YAAY,mBAAmB,eAAe,kBAAkB,wBAAwB;CAAC;AAAA,aAAa,cAAc,eAAe,yCAAyC;CAAC;AAAA,SAAS,WAAW,UAAU,WAAW;CAAC","file":"link.vue","sourcesContent":[".mar{margin:auto}.link_bac{display:flex;height:40px;width:120px;margin:auto 0}.qub{display:flex;height:30px;width:30px;margin:auto 3px;background-color:rgba(0,0,0,0.4);border-radius:8px}.qub:hover{cursor:pointer;background-color:rgba(66,185,131,0.8);box-shadow:0 0 10px rgba(66,185,131,0.6)}.qub_2{display:flex;height:30px;width:30px;margin:auto 5px auto 3px;color:black;font-weight:bolder;font-size:14px;border-radius:8px;background-color:#ffffff}.qub_2:hover{color:#42b983;cursor:pointer;box-shadow:0 0 10px rgba(255,255,255,0.3)}.qub_img{height:90%;width:90%;margin:auto}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "link_bac" }, [
    _vm._m(0),
    _vm._v(" "),
    _vm._m(1),
    _vm._v(" "),
    _c("div", { staticClass: "qub_2", on: { click: _vm.language } }, [
      _c("a", { staticClass: "mar" }, [_vm._v(_vm._s(_vm.lan))])
    ])
  ])
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "div",
      { staticClass: "qub", staticStyle: { margin: "auto 3px auto auto" } },
      [
        _c("img", {
          staticClass: "qub_img",
          attrs: { src: __webpack_require__(39), alt: "" }
        })
      ]
    )
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "qub" }, [
      _c("img", {
        staticClass: "qub_img",
        attrs: { src: __webpack_require__(40), alt: "" }
      })
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-0074f58f", esExports)
  }
}

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIEAYAAAD9yHLdAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAASAAAAEgARslrPgAAGMZJREFUeNrt3XmUFNX1B/D7ZlgUFRkkyiIoBJSgSEBExORHICYCgjIhSkSjcAC3g9HgnogS9RiPGxoVAiIoLmhUQIEYFRMVZRPZoiAGZQQFMYaRRUCWfr8/vtweembAme7qvl1V388/97yamZ5b3dV1q15VvSdCRERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERE0eKsE6Bo8gmf8IlatcSJE3fIIbrcOeecKy21zo+IMscCQimw469bF63jj0cBaNMG7datU+MRRyAWFSHWqydevPiiovKF48C2bUP87jvEzZsR165FLCnB665di9ddswbL16zB8g8+cAWuwBXociLKBRaQmPDee++dww73xBOxI/75z/HT7t0R27dHPPpo63zTs3494nvvIc6fj/VdsECXo9Bs2mSdKVEUsIBEDM4gGjRAq7g4tVB064Z45JHWedrYswcFZfZsvC8vvYTl06aha62kxDpDojBhAQkpFIratbEjPOssLL3oIsRevRBr1rTOMzS8ePFLluD9nDYN7cmTccby8cfW6RHlIxaQkEAXVIcOaA0Zgti/P2L9+tb5RZP3iK+/joLy8MMoMDNn4owlkbDOkMgSC0ieQsHo0QM7rmuvTe2KIlurV+NzGTMGn8tjj6GgbNxonRkRxRAKRpcuiG+95SkcEj7hE1u3onHXXWgfdpj19kSUCzwDMYIdzXHHofXAAziS7dnTOi8Kwrp1OEMZORLtiRNxLWX3buvMiILEApIjOEKtUwetW25B/P3vEWvVss6PsmnFCsTrrkNX18yZ1hkRBYEFJMtQOE47Da2JExGPP946L7I0YwbipZeioKxbZ50RUToKrBOIGnRN1aiBeOedWDp7NiILB4mI9O6NLq6l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"

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_notice_vue__ = __webpack_require__(8);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4f859ae2_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_notice_vue__ = __webpack_require__(47);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(42)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_notice_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4f859ae2_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_notice_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/notice/notice.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4f859ae2", Component.options)
  } else {
    hotAPI.reload("data-v-4f859ae2", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(43);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("28b0b0c5", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-4f859ae2\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./notice.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-4f859ae2\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./notice.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.roll_container_notice{position:fixed;top:72px;left:0;z-index:99;display:flex;height:45px;width:45px;color:#161616;transition:width 400ms, background-color 400ms, box-shadow 400ms;border-top-right-radius:10px;border-bottom-right-radius:10px;background-color:rgba(0,0,0,0.1);box-shadow:0 0 5px rgba(0,0,0,0.1);overflow:hidden\n}\n.roll_container_notice:hover{box-shadow:0 0 5px rgba(66,185,131,0.4)\n}\n[data-theme=\"green\"] .roll_container_notice:hover{box-shadow:0 0 5px rgba(66,185,131,0.4)\n}\n[data-theme=\"red\"] .roll_container_notice:hover{box-shadow:0 0 5px rgba(251,114,153,0.4)\n}\n[data-theme=\"blue\"] .roll_container_notice:hover{box-shadow:0 0 5px rgba(19,120,255,0.4)\n}\n.roll_container_notice_click{width:340px;background-color:white;border-right:3px solid #42b983;box-shadow:0 0 3px rgba(66,185,131,0.4)\n}\n[data-theme=\"green\"] .roll_container_notice_click{border-right:3px solid #42b983\n}\n[data-theme=\"red\"] .roll_container_notice_click{border-right:3px solid #fb7299\n}\n[data-theme=\"blue\"] .roll_container_notice_click{border-right:3px solid #1378ff\n}\n[data-theme=\"green\"] .roll_container_notice_click{box-shadow:0 0 3px rgba(66,185,131,0.4)\n}\n[data-theme=\"red\"] .roll_container_notice_click{box-shadow:0 0 3px rgba(251,114,153,0.4)\n}\n[data-theme=\"blue\"] .roll_container_notice_click{box-shadow:0 0 3px rgba(19,120,255,0.4)\n}\n.roll_container_img{position:absolute;display:flex;height:45px;width:45px\n}\n.roll_container_img img{margin:auto;height:22px;width:22px\n}\n.roll_container_img:hover{cursor:pointer\n}\n.notice_frame{width:300px;margin-left:50px\n}\n.notice_word{display:flex;width:300px;height:45px\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/notice/notice.vue"],"names":[],"mappings":";AAAA,uBAAuB,eAAe,SAAS,OAAO,WAAW,aAAa,YAAY,WAAW,cAAc,iEAAiE,6BAA6B,gCAAgC,iCAAiC,mCAAmC,eAAe;CAAC;AAAA,6BAA6B,uCAAuC;CAAC;AAAA,kDAAkD,uCAAuC;CAAC;AAAA,gDAAgD,wCAAwC;CAAC;AAAA,iDAAiD,uCAAuC;CAAC;AAAA,6BAA6B,YAAY,uBAAuB,+BAA+B,uCAAuC;CAAC;AAAA,kDAAkD,8BAA8B;CAAC;AAAA,gDAAgD,8BAA8B;CAAC;AAAA,iDAAiD,8BAA8B;CAAC;AAAA,kDAAkD,uCAAuC;CAAC;AAAA,gDAAgD,wCAAwC;CAAC;AAAA,iDAAiD,uCAAuC;CAAC;AAAA,oBAAoB,kBAAkB,aAAa,YAAY,UAAU;CAAC;AAAA,wBAAwB,YAAY,YAAY,UAAU;CAAC;AAAA,0BAA0B,cAAc;CAAC;AAAA,cAAc,YAAY,gBAAgB;CAAC;AAAA,aAAa,aAAa,YAAY,WAAW;CAAC","file":"notice.vue","sourcesContent":[".roll_container_notice{position:fixed;top:72px;left:0;z-index:99;display:flex;height:45px;width:45px;color:#161616;transition:width 400ms, background-color 400ms, box-shadow 400ms;border-top-right-radius:10px;border-bottom-right-radius:10px;background-color:rgba(0,0,0,0.1);box-shadow:0 0 5px rgba(0,0,0,0.1);overflow:hidden}.roll_container_notice:hover{box-shadow:0 0 5px rgba(66,185,131,0.4)}[data-theme=\"green\"] .roll_container_notice:hover{box-shadow:0 0 5px rgba(66,185,131,0.4)}[data-theme=\"red\"] .roll_container_notice:hover{box-shadow:0 0 5px rgba(251,114,153,0.4)}[data-theme=\"blue\"] .roll_container_notice:hover{box-shadow:0 0 5px rgba(19,120,255,0.4)}.roll_container_notice_click{width:340px;background-color:white;border-right:3px solid #42b983;box-shadow:0 0 3px rgba(66,185,131,0.4)}[data-theme=\"green\"] .roll_container_notice_click{border-right:3px solid #42b983}[data-theme=\"red\"] .roll_container_notice_click{border-right:3px solid #fb7299}[data-theme=\"blue\"] .roll_container_notice_click{border-right:3px solid #1378ff}[data-theme=\"green\"] .roll_container_notice_click{box-shadow:0 0 3px rgba(66,185,131,0.4)}[data-theme=\"red\"] .roll_container_notice_click{box-shadow:0 0 3px rgba(251,114,153,0.4)}[data-theme=\"blue\"] .roll_container_notice_click{box-shadow:0 0 3px rgba(19,120,255,0.4)}.roll_container_img{position:absolute;display:flex;height:45px;width:45px}.roll_container_img img{margin:auto;height:22px;width:22px}.roll_container_img:hover{cursor:pointer}.notice_frame{width:300px;margin-left:50px}.notice_word{display:flex;width:300px;height:45px}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ssr_window__ = __webpack_require__(9);
/**
 * Swiper 4.5.0
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://www.idangero.us/swiper/
 *
 * Copyright 2014-2019 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: February 22, 2019
 */




const Methods = {
  addClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["c" /* addClass */],
  removeClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["E" /* removeClass */],
  hasClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["m" /* hasClass */],
  toggleClass: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["H" /* toggleClass */],
  attr: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["e" /* attr */],
  removeAttr: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["D" /* removeAttr */],
  data: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["i" /* data */],
  transform: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["I" /* transform */],
  transition: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["J" /* transition */],
  on: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["u" /* on */],
  off: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["s" /* off */],
  trigger: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["L" /* trigger */],
  transitionEnd: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["K" /* transitionEnd */],
  outerWidth: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["w" /* outerWidth */],
  outerHeight: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["v" /* outerHeight */],
  offset: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["t" /* offset */],
  css: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["h" /* css */],
  each: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["j" /* each */],
  html: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["n" /* html */],
  text: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["G" /* text */],
  is: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["p" /* is */],
  index: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["o" /* index */],
  eq: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["k" /* eq */],
  append: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["d" /* append */],
  prepend: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["z" /* prepend */],
  next: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["q" /* next */],
  nextAll: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["r" /* nextAll */],
  prev: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["A" /* prev */],
  prevAll: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["B" /* prevAll */],
  parent: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["x" /* parent */],
  parents: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["y" /* parents */],
  closest: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["g" /* closest */],
  find: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["l" /* find */],
  children: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["f" /* children */],
  remove: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["C" /* remove */],
  add: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["b" /* add */],
  styles: __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["F" /* styles */],
};

Object.keys(Methods).forEach((methodName) => {
  __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */].fn[methodName] = Methods[methodName];
});

const Utils = {
  deleteProps(obj) {
    const object = obj;
    Object.keys(object).forEach((key) => {
      try {
        object[key] = null;
      } catch (e) {
        // no getter for object
      }
      try {
        delete object[key];
      } catch (e) {
        // something got wrong
      }
    });
  },
  nextTick(callback, delay = 0) {
    return setTimeout(callback, delay);
  },
  now() {
    return Date.now();
  },
  getTranslate(el, axis = 'x') {
    let matrix;
    let curTransform;
    let transformMatrix;

    const curStyle = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].getComputedStyle(el, null);

    if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].WebKitCSSMatrix) {
      curTransform = curStyle.transform || curStyle.webkitTransform;
      if (curTransform.split(',').length > 6) {
        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
      }
      // Some old versions of Webkit choke when 'none' is passed; pass
      // empty string instead in this case
      transformMatrix = new __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
    } else {
      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
      matrix = transformMatrix.toString().split(',');
    }

    if (axis === 'x') {
      // Latest Chrome and webkits Fix
      if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].WebKitCSSMatrix) curTransform = transformMatrix.m41;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[4]);
    }
    if (axis === 'y') {
      // Latest Chrome and webkits Fix
      if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].WebKitCSSMatrix) curTransform = transformMatrix.m42;
      // Crazy IE10 Matrix
      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
      // Normal Browsers
      else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
  },
  parseUrlQuery(url) {
    const query = {};
    let urlToParse = url || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].location.href;
    let i;
    let params;
    let param;
    let length;
    if (typeof urlToParse === 'string' && urlToParse.length) {
      urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
      params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');
      length = params.length;

      for (i = 0; i < length; i += 1) {
        param = params[i].replace(/#\S+/g, '').split('=');
        query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
      }
    }
    return query;
  },
  isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
  },
  extend(...args) {
    const to = Object(args[0]);
    for (let i = 1; i < args.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  },
};

const Support = (function Support() {
  const testDiv = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].createElement('div');
  return {
    touch: (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].Modernizr && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].Modernizr.touch === true) || (function checkTouch() {
      return !!((__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.maxTouchPoints > 0) || ('ontouchstart' in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */]) || (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].DocumentTouch && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */] instanceof __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].DocumentTouch));
    }()),

    pointerEvents: !!(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.pointerEnabled || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].PointerEvent || ('maxTouchPoints' in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.maxTouchPoints > 0)),
    prefixedPointerEvents: !!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.msPointerEnabled,

    transition: (function checkTransition() {
      const style = testDiv.style;
      return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);
    }()),
    transforms3d: (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].Modernizr && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].Modernizr.csstransforms3d === true) || (function checkTransforms3d() {
      const style = testDiv.style;
      return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);
    }()),

    flexbox: (function checkFlexbox() {
      const style = testDiv.style;
      const styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
      for (let i = 0; i < styles.length; i += 1) {
        if (styles[i] in style) return true;
      }
      return false;
    }()),

    observer: (function checkObserver() {
      return ('MutationObserver' in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */] || 'WebkitMutationObserver' in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */]);
    }()),

    passiveListener: (function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get() {
            supportsPassive = true;
          },
        });
        __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].addEventListener('testPassiveListener', null, opts);
      } catch (e) {
        // No support
      }
      return supportsPassive;
    }()),

    gestures: (function checkGestures() {
      return 'ongesturestart' in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */];
    }()),
  };
}());

const Browser = (function Browser() {
  function isSafari() {
    const ua = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.userAgent.toLowerCase();
    return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
  }
  return {
    isIE: !!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.userAgent.match(/Trident/g) || !!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.userAgent.match(/MSIE/g),
    isEdge: !!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.userAgent),
  };
}());

class SwiperClass {
  constructor(params = {}) {
    const self = this;
    self.params = params;

    // Events
    self.eventsListeners = {};

    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach((eventName) => {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  }

  on(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach((event) => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  }

  once(events, handler, priority) {
    const self = this;
    if (typeof handler !== 'function') return self;
    function onceHandler(...args) {
      handler.apply(self, args);
      self.off(events, onceHandler);
      if (onceHandler.f7proxy) {
        delete onceHandler.f7proxy;
      }
    }
    onceHandler.f7proxy = handler;
    return self.on(events, onceHandler, priority);
  }

  off(events, handler) {
    const self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach((event) => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  }

  emit(...args) {
    const self = this;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach((event) => {
      if (self.eventsListeners && self.eventsListeners[event]) {
        const handlers = [];
        self.eventsListeners[event].forEach((eventHandler) => {
          handlers.push(eventHandler);
        });
        handlers.forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }

  useModulesParams(instanceParams) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      // Extend params
      if (module.params) {
        Utils.extend(instanceParams, module.params);
      }
    });
  }

  useModules(modulesParams = {}) {
    const instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach((moduleName) => {
      const module = instance.modules[moduleName];
      const moduleParams = modulesParams[moduleName] || {};
      // Extend instance methods and props
      if (module.instance) {
        Object.keys(module.instance).forEach((modulePropName) => {
          const moduleProp = module.instance[modulePropName];
          if (typeof moduleProp === 'function') {
            instance[modulePropName] = moduleProp.bind(instance);
          } else {
            instance[modulePropName] = moduleProp;
          }
        });
      }
      // Add event listeners
      if (module.on && instance.on) {
        Object.keys(module.on).forEach((moduleEventName) => {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      }

      // Module create callback
      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }

  static set components(components) {
    const Class = this;
    if (!Class.use) return;
    Class.use(components);
  }

  static installModule(module, ...params) {
    const Class = this;
    if (!Class.prototype.modules) Class.prototype.modules = {};
    const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);
    Class.prototype.modules[name] = module;
    // Prototype
    if (module.proto) {
      Object.keys(module.proto).forEach((key) => {
        Class.prototype[key] = module.proto[key];
      });
    }
    // Class
    if (module.static) {
      Object.keys(module.static).forEach((key) => {
        Class[key] = module.static[key];
      });
    }
    // Callback
    if (module.install) {
      module.install.apply(Class, params);
    }
    return Class;
  }

  static use(module, ...params) {
    const Class = this;
    if (Array.isArray(module)) {
      module.forEach(m => Class.installModule(m));
      return Class;
    }
    return Class.installModule(module, ...params);
  }
}

function updateSize () {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;
  if (typeof swiper.params.width !== 'undefined') {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined') {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
    return;
  }

  // Subtract paddings
  width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
  height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

  Utils.extend(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height,
  });
}

function updateSlides () {
  const swiper = this;
  const params = swiper.params;

  const {
    $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];

  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }

  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }

  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.snapGrid.length;

  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
  }

  swiper.virtualSize = -spaceBetween;

  // reset margins
  if (rtl) slides.css({ marginLeft: '', marginTop: '' });
  else slides.css({ marginRight: '', marginBottom: '' });

  let slidesNumberEvenToRows;
  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }
    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  }

  // Calc slides
  let slideSize;
  const slidesPerColumn = params.slidesPerColumn;
  const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);
    if (params.slidesPerColumn > 1) {
      // Set slides order
      let newSlideOrderIndex;
      let column;
      let row;
      if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - (column * slidesPerColumn);
        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
          row += 1;
          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
        newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
        slide
          .css({
            '-webkit-box-ordinal-group': newSlideOrderIndex,
            '-moz-box-ordinal-group': newSlideOrderIndex,
            '-ms-flex-order': newSlideOrderIndex,
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex,
          });
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - (row * slidesPerRow);
      }
      slide
        .css(
          `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,
          (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)
        )
        .attr('data-swiper-column', column)
        .attr('data-swiper-row', row);
    }
    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      const slideStyles = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].getComputedStyle(slide[0], null);
      const currentTransform = slide[0].style.transform;
      const currentWebKitTransform = slide[0].style.webkitTransform;
      if (currentTransform) {
        slide[0].style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal()
          ? slide.outerWidth(true)
          : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        if (swiper.isHorizontal()) {
          const width = parseFloat(slideStyles.getPropertyValue('width'));
          const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
          const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
          const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
          const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box') {
            slideSize = width + marginLeft + marginRight;
          } else {
            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
          }
        } else {
          const height = parseFloat(slideStyles.getPropertyValue('height'));
          const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
          const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
          const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
          const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
          const boxSizing = slideStyles.getPropertyValue('box-sizing');
          if (boxSizing && boxSizing === 'border-box') {
            slideSize = height + marginTop + marginBottom;
          } else {
            slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
          }
        }
      }
      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);

      if (slides[i]) {
        if (swiper.isHorizontal()) {
          slides[i].style.width = `${slideSize}px`;
        } else {
          slides[i].style.height = `${slideSize}px`;
        }
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);


    if (params.centeredSlides) {
      slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }

    swiper.virtualSize += slideSize + spaceBetween;

    prevSlideSize = slideSize;

    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  let newSlidesGrid;

  if (
    rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
  }
  if (!Support.flexbox || params.setWrapperSize) {
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
  }

  if (params.slidesPerColumn > 1) {
    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
    if (params.centeredSlides) {
      newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid = newSlidesGrid;
    }
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];

  if (params.spaceBetween !== 0) {
    if (swiper.isHorizontal()) {
      if (rtl) slides.css({ marginLeft: `${spaceBetween}px` });
      else slides.css({ marginRight: `${spaceBetween}px` });
    } else slides.css({ marginBottom: `${spaceBetween}px` });
  }

  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }

  Utils.extend(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid,
  });

  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }

  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}

function updateAutoHeight (speed) {
  const swiper = this;
  const activeSlides = [];
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
      const index = swiper.activeIndex + i;
      if (index > swiper.slides.length) break;
      activeSlides.push(swiper.slides.eq(index)[0]);
    }
  } else {
    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
}

function updateSlidesOffset () {
  const swiper = this;
  const slides = swiper.slides;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

function updateSlidesProgress (translate = (this && this.translate) || 0) {
  const swiper = this;
  const params = swiper.params;

  const { slides, rtlTranslate: rtl } = swiper;

  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();

  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;

  // Visible Slides
  slides.removeClass(params.slideVisibleClass);

  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];

  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    const slideProgress = (
      (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
    ) / (slide.swiperSlideSize + params.spaceBetween);
    if (params.watchSlidesVisibility) {
      const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      const isVisible = (slideBefore >= 0 && slideBefore < swiper.size)
                || (slideAfter > 0 && slideAfter <= swiper.size)
                || (slideBefore <= 0 && slideAfter >= swiper.size);
      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
  }
  swiper.visibleSlides = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(swiper.visibleSlides);
}

function updateProgress (translate = (this && this.translate) || 0) {
  const swiper = this;
  const params = swiper.params;

  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let { progress, isBeginning, isEnd } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / (translatesDiff);
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  Utils.extend(swiper, {
    progress,
    isBeginning,
    isEnd,
  });

  if (params.watchSlidesProgress || params.watchSlidesVisibility) swiper.updateSlidesProgress(translate);

  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
    swiper.emit('fromEdge');
  }

  swiper.emit('progress', progress);
}

function updateSlidesClasses () {
  const swiper = this;

  const {
    slides, params, $wrapperEl, activeIndex, realIndex,
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;

  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);

  let activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  }

  // Active classes
  activeSlide.addClass(params.slideActiveClass);

  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`)
        .addClass(params.slideDuplicateActiveClass);
    }
  }
  // Next Slide
  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  // Prev Slide
  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl
        .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl
        .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
        .addClass(params.slideDuplicatePrevClass);
    }
  }
}

function updateActiveIndex (newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  if (typeof activeIndex === 'undefined') {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }

  // Get real index
  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

  Utils.extend(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex,
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }
  swiper.emit('slideChange');
}

function updateClickedSlide (e) {
  const swiper = this;
  const params = swiper.params;
  const slide = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(e.target).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) slideFound = true;
    }
  }

  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(slide).index();
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide,
};

function getTranslate (axis = this.isHorizontal() ? 'x' : 'y') {
  const swiper = this;

  const {
    params, rtlTranslate: rtl, translate, $wrapperEl,
  } = swiper;

  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }

  let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;

  return currentTranslate || 0;
}

function setTranslate (translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl, params, $wrapperEl, progress,
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;

  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }

  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }

  if (!params.virtualTranslate) {
    if (Support.transforms3d) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
    else $wrapperEl.transform(`translate(${x}px, ${y}px)`);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }

  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate () {
  return (-this.snapGrid[0]);
}

function maxTranslate () {
  return (-this.snapGrid[this.snapGrid.length - 1]);
}

var translate = {
  getTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
};

function setTransition (duration, byController) {
  const swiper = this;

  swiper.$wrapperEl.transition(duration);

  swiper.emit('setTransition', duration, byController);
}

function transitionStart (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, params, previousIndex } = swiper;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionStart');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }
    swiper.emit('slideChangeTransitionStart');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}

function transitionEnd (runCallbacks = true, direction) {
  const swiper = this;
  const { activeIndex, previousIndex } = swiper;
  swiper.animating = false;
  swiper.setTransition(0);

  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';
    else if (activeIndex < previousIndex) dir = 'prev';
    else dir = 'reset';
  }

  swiper.emit('transitionEnd');

  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }
    swiper.emit('slideChangeTransitionEnd');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}

var transition = {
  setTransition,
  transitionStart,
  transitionEnd,
};

function slideTo (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;

  const {
    params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl,
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }

  let snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  const translate = -snapGrid[snapIndex];

  // Update progress
  swiper.updateProgress(translate);

  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }

  let direction;
  if (slideIndex > activeIndex) direction = 'next';
  else if (slideIndex < activeIndex) direction = 'prev';
  else direction = 'reset';


  // Update Index
  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }

  if (speed === 0 || !Support.transition) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }

  return true;
}

function slideToLoop (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let newIndex = index;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }

  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideNext (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const { params, animating } = swiper;
  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params, animating, snapGrid, slidesGrid, rtlTranslate,
  } = swiper;

  if (params.loop) {
    if (animating) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
  const normalizedSlidesGrid = slidesGrid.map(val => normalize(val));

  const currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
  const prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  let prevIndex;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest (speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  let index = swiper.activeIndex;
  const snapIndex = Math.floor(index / swiper.params.slidesPerGroup);

  if (snapIndex < swiper.snapGrid.length - 1) {
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];

    if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {
      index = swiper.params.slidesPerGroup;
    }
  }

  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;

  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (
        (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
        || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
      ) {
        swiper.loopFix();
        slideToIndex = $wrapperEl
          .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
          .eq(0)
          .index();

        Utils.nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl
        .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
        .eq(0)
        .index();

      Utils.nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide,
};

function loopCreate () {
  const swiper = this;
  const { params, $wrapperEl } = swiper;
  // Remove duplicated slides
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();

  let slides = $wrapperEl.children(`.${params.slideClass}`);

  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $wrapperEl.append(blankNode);
      }
      slides = $wrapperEl.children(`.${params.slideClass}`);
    }
  }

  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;

  swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }

  const prependSlides = [];
  const appendSlides = [];
  slides.each((index, el) => {
    const slide = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(el);
    if (index < swiper.loopedSlides) appendSlides.push(el);
    if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);
    slide.attr('data-swiper-slide-index', index);
  });
  for (let i = 0; i < appendSlides.length; i += 1) {
    $wrapperEl.append(Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $wrapperEl.prepend(Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

function loopFix () {
  const swiper = this;
  const {
    params, activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;

  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate();


  // Fix For Negative Oversliding
  if (activeIndex < loopedSlides) {
    newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex >= slides.length - loopedSlides)) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
}

function loopDestroy () {
  const swiper = this;
  const { $wrapperEl, params, slides } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr('data-swiper-slide-index');
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy,
};

function setGrabCursor (moving) {
  const swiper = this;
  if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) return;
  const el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}

function unsetGrabCursor () {
  const swiper = this;
  if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) return;
  swiper.el.style.cursor = '';
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor,
};

function appendSlide (slides) {
  const swiper = this;
  const { $wrapperEl, params } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
}

function prependSlide (slides) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

function addSlide (index, slides) {
  const swiper = this;
  const { $wrapperEl, params, activeIndex } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  const baseLength = swiper.slides.length;
  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;

  const slidesBuffer = [];
  for (let i = baseLength - 1; i >= index; i -= 1) {
    const currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }

  if (typeof slides === 'object' && 'length' in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }

  for (let i = 0; i < slidesBuffer.length; i += 1) {
    $wrapperEl.append(slidesBuffer[i]);
  }

  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeSlide (slidesIndexes) {
  const swiper = this;
  const { params, $wrapperEl, activeIndex } = swiper;

  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;

  if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }

  if (params.loop) {
    swiper.loopCreate();
  }

  if (!(params.observer && Support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

function removeAllSlides () {
  const swiper = this;

  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

var manipulation = {
  appendSlide,
  prependSlide,
  addSlide,
  removeSlide,
  removeAllSlides,
};

const Device = (function Device() {
  const ua = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.userAgent;

  const device = {
    ios: false,
    android: false,
    androidChrome: false,
    desktop: false,
    windows: false,
    iphone: false,
    ipod: false,
    ipad: false,
    cordova: __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].cordova || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].phonegap,
    phonegap: __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].cordova || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].phonegap,
  };

  const windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  const ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);


  // Windows
  if (windows) {
    device.os = 'windows';
    device.osVersion = windows[2];
    device.windows = true;
  }
  // Android
  if (android && !windows) {
    device.os = 'android';
    device.osVersion = android[2];
    device.android = true;
    device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }
  // iOS
  if (iphone && !ipod) {
    device.osVersion = iphone[2].replace(/_/g, '.');
    device.iphone = true;
  }
  if (ipad) {
    device.osVersion = ipad[2].replace(/_/g, '.');
    device.ipad = true;
  }
  if (ipod) {
    device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
    device.iphone = true;
  }
  // iOS 8+ changed UA
  if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
    if (device.osVersion.split('.')[0] === '10') {
      device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
    }
  }

  // Desktop
  device.desktop = !(device.os || device.android || device.webView);

  // Webview
  device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);

  // Minimal UI
  if (device.os && device.os === 'ios') {
    const osVersionArr = device.osVersion.split('.');
    const metaViewport = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].querySelector('meta[name="viewport"]');
    device.minimalUi = !device.webView
      && (ipod || iphone)
      && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7)
      && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;
  }

  // Pixel Ratio
  device.pixelRatio = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].devicePixelRatio || 1;

  // Export object
  return device;
}());

function onTouchStart (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;
  if (params.noSwiping && Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(e).closest(params.swipeHandler)[0]) return;
  }

  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (
    edgeSwipeDetection
    && ((startX <= edgeSwipeThreshold)
    || (startX >= __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].screen.width - edgeSwipeThreshold))
  ) {
    return;
  }

  Utils.extend(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined,
  });

  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = Utils.now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  if (e.type !== 'touchstart') {
    let preventDefault = true;
    if (Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(e.target).is(data.formElements)) preventDefault = false;
    if (
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].activeElement
      && Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].activeElement).is(data.formElements)
      && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].activeElement !== e.target
    ) {
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].activeElement.blur();
    }

    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if (params.touchStartForcePreventDefault || shouldPreventDefault) {
      e.preventDefault();
    }
  }
  swiper.emit('touchStart', e);
}

function onTouchMove (event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const { params, touches, rtlTranslate: rtl } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  if (data.isTouchEvent && e.type === 'mousemove') return;
  const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
  const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;
    if (data.isTouched) {
      Utils.extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY,
      });
      data.touchStartTime = Utils.now();
    }
    return;
  }
  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (
        (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
        || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
      ) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (
      (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
      || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
    ) {
      return;
    }
  }
  if (data.isTouchEvent && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].activeElement) {
    if (e.target === __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].activeElement && Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(e.target).is(data.formElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  if (e.targetTouches && e.targetTouches.length > 1) return;

  touches.currentX = pageX;
  touches.currentY = pageY;

  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt((diffX ** 2) + (diffY ** 2)) < swiper.params.threshold) return;

  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if ((diffX * diffX) + (diffY * diffY) >= 25) {
        touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  e.preventDefault();
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }

  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;

  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;

  diff *= params.touchRatio;
  if (rtl) diff = -diff;

  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;

  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio);
  }

  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }


  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }

  if (!params.followFinger) return;

  // Update active index in free mode
  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime,
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: Utils.now(),
    });
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd (event) {
  const swiper = this;
  const data = swiper.touchEventsData;

  const {
    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,
  } = swiper;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = Utils.now();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap', e);
    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {
      if (data.clickTimeout) clearTimeout(data.clickTimeout);
      data.clickTimeout = Utils.nextTick(() => {
        if (!swiper || swiper.destroyed) return;
        swiper.emit('click', e);
      }, 300);
    }
    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
      if (data.clickTimeout) clearTimeout(data.clickTimeout);
      swiper.emit('doubleTap', e);
    }
  }

  data.lastClickTime = Utils.now();
  Utils.nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });

  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;

  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }

  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }

    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();

        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeModeMomentumVelocityRatio;

      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeModeMomentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;

      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;

      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }

        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        swiper.once('transitionEnd', () => {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(() => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');

          swiper.setTransition(params.speed);
          swiper.setTranslate(afterBouncePosition);
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    }

    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    return;
  }

  // Find current slide
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
    if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {
        stopIndex = i;
        groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }

  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;

  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + params.slidesPerGroup);
      else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + params.slidesPerGroup);
      else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      swiper.slideTo(stopIndex + params.slidesPerGroup);
    }
    if (swiper.swipeDirection === 'prev') {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize () {
  const swiper = this;

  const { params, el } = swiper;

  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;

  swiper.updateSize();
  swiper.updateSlides();

  if (params.freeMode) {
    const newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());
    swiper.setTranslate(newTranslate);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
  } else {
    swiper.updateSlidesClasses();
    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;

  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick (e) {
  const swiper = this;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function attachEvents() {
  const swiper = this;
  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  {
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
  }

  swiper.onClick = onClick.bind(swiper);

  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
  const capture = !!params.nested;

  // Touch Events
  {
    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
      target.addEventListener(touchEvents.start, swiper.onTouchStart, false);
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].addEventListener(touchEvents.move, swiper.onTouchMove, capture);
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].addEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (Support.touch) {
        const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture } : capture);
        target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      }
      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
        target.addEventListener('mousedown', swiper.onTouchStart, false);
        __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].addEventListener('mousemove', swiper.onTouchMove, capture);
        __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].addEventListener('mouseup', swiper.onTouchEnd, false);
      }
    }
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      target.addEventListener('click', swiper.onClick, true);
    }
  }

  // Resize handler
  swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
}

function detachEvents() {
  const swiper = this;

  const {
    params, touchEvents, el, wrapperEl,
  } = swiper;

  const target = params.touchEventsTarget === 'container' ? el : wrapperEl;
  const capture = !!params.nested;

  // Touch Events
  {
    if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {
      target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (Support.touch) {
        const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      }
      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
        target.removeEventListener('mousedown', swiper.onTouchStart, false);
        __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].removeEventListener('mousemove', swiper.onTouchMove, capture);
        __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].removeEventListener('mouseup', swiper.onTouchEnd, false);
      }
    }
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      target.removeEventListener('click', swiper.onClick, true);
    }
  }

  // Resize handler
  swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
}

var events = {
  attachEvents,
  detachEvents,
};

function setBreakpoint () {
  const swiper = this;
  const {
    activeIndex, initialized, loopedSlides = 0, params,
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;

  // Set breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints);

  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
    if (breakpointOnlyParams) {
      ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach((param) => {
        const paramValue = breakpointOnlyParams[param];
        if (typeof paramValue === 'undefined') return;
        if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
          breakpointOnlyParams[param] = 'auto';
        } else if (param === 'slidesPerView') {
          breakpointOnlyParams[param] = parseFloat(paramValue);
        } else {
          breakpointOnlyParams[param] = parseInt(paramValue, 10);
        }
      });
    }

    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

    if (directionChanged && initialized) {
      swiper.changeDirection();
    }

    Utils.extend(swiper.params, breakpointParams);

    Utils.extend(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
    });

    swiper.currentBreakpoint = breakpoint;

    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
    }

    swiper.emit('breakpoint', breakpointParams);
  }
}

function getBreakpoint (breakpoints) {
  const swiper = this;
  // Get breakpoint for window width
  if (!breakpoints) return undefined;
  let breakpoint = false;
  const points = [];
  Object.keys(breakpoints).forEach((point) => {
    points.push(point);
  });
  points.sort((a, b) => parseInt(a, 10) - parseInt(b, 10));
  for (let i = 0; i < points.length; i += 1) {
    const point = points[i];
    if (swiper.params.breakpointsInverse) {
      if (point <= __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].innerWidth) {
        breakpoint = point;
      }
    } else if (point >= __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].innerWidth && !breakpoint) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var breakpoints = { setBreakpoint, getBreakpoint };

function addClasses () {
  const swiper = this;
  const {
    classNames, params, rtl, $el,
  } = swiper;
  const suffixes = [];

  suffixes.push('initialized');
  suffixes.push(params.direction);

  if (params.freeMode) {
    suffixes.push('free-mode');
  }
  if (!Support.flexbox) {
    suffixes.push('no-flexbox');
  }
  if (params.autoHeight) {
    suffixes.push('autoheight');
  }
  if (rtl) {
    suffixes.push('rtl');
  }
  if (params.slidesPerColumn > 1) {
    suffixes.push('multirow');
  }
  if (Device.android) {
    suffixes.push('android');
  }
  if (Device.ios) {
    suffixes.push('ios');
  }
  // WP8 Touch Events Fix
  if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
    suffixes.push(`wp8-${params.direction}`);
  }

  suffixes.forEach((suffix) => {
    classNames.push(params.containerModifierClass + suffix);
  });

  $el.addClass(classNames.join(' '));
}

function removeClasses () {
  const swiper = this;
  const { $el, classNames } = swiper;

  $el.removeClass(classNames.join(' '));
}

var classes = { addClasses, removeClasses };

function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
  let image;
  function onReady() {
    if (callback) callback();
  }
  if (!imageEl.complete || !checkForComplete) {
    if (src) {
      image = new __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    // image already loaded...
    onReady();
  }
}

function preloadImages () {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find('img');
  function onReady() {
    if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
    if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady) swiper.update();
      swiper.emit('imagesReady');
    }
  }
  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(
      imageEl,
      imageEl.currentSrc || imageEl.getAttribute('src'),
      imageEl.srcset || imageEl.getAttribute('srcset'),
      imageEl.sizes || imageEl.getAttribute('sizes'),
      true,
      onReady
    );
  }
}

var images = {
  loadImage,
  preloadImages,
};

function checkOverflow() {
  const swiper = this;
  const wasLocked = swiper.isLocked;

  swiper.isLocked = swiper.snapGrid.length === 1;
  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked;

  // events
  if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    swiper.navigation.update();
  }
}

var checkOverflow$1 = { checkOverflow };

var defaults = {
  init: true,
  direction: 'horizontal',
  touchEventsTarget: 'container',
  initialSlide: 0,
  speed: 300,
  //
  preventInteractionOnTransition: false,

  // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,

  // Free mode
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,

  // Autoheight
  autoHeight: false,

  // Set wrapper width
  setWrapperSize: false,

  // Virtual Translate
  virtualTranslate: false,

  // Effects
  effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,
  breakpointsInverse: false,

  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: 'column',
  slidesPerGroup: 1,
  centeredSlides: false,
  slidesOffsetBefore: 0, // in px
  slidesOffsetAfter: 0, // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,

  // Disable swiper and hide navigation when container not overflow
  watchOverflow: false,

  // Round length
  roundLengths: false,

  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: true,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,

  // Unique Navigation Elements
  uniqueNavElements: true,

  // Resistance
  resistance: true,
  resistanceRatio: 0.85,

  // Progress
  watchSlidesProgress: false,
  watchSlidesVisibility: false,

  // Cursor
  grabCursor: false,

  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,

  // Images
  preloadImages: true,
  updateOnImagesReady: true,

  // loop
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,

  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null, // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,

  // Passive Listeners
  passiveListeners: true,

  // NS
  containerModifierClass: 'swiper-container-', // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-invisible-blank',
  slideActiveClass: 'swiper-slide-active',
  slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideDuplicateClass: 'swiper-slide-duplicate',
  slideNextClass: 'swiper-slide-next',
  slideDuplicateNextClass: 'swiper-slide-duplicate-next',
  slidePrevClass: 'swiper-slide-prev',
  slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
  wrapperClass: 'swiper-wrapper',

  // Callbacks
  runCallbacksOnInit: true,
};

/* eslint no-param-reassign: "off" */

const prototypes = {
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  manipulation,
  events,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes,
  images,
};

const extendedDefaults = {};

class Swiper extends SwiperClass {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};

    params = Utils.extend({}, params);
    if (el && !params.el) params.el = el;

    super(params);

    Object.keys(prototypes).forEach((prototypeGroup) => {
      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
        if (!Swiper.prototype[protoMethod]) {
          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
        }
      });
    });

    // Swiper Instance
    const swiper = this;
    if (typeof swiper.modules === 'undefined') {
      swiper.modules = {};
    }
    Object.keys(swiper.modules).forEach((moduleName) => {
      const module = swiper.modules[moduleName];
      if (module.params) {
        const moduleParamName = Object.keys(module.params)[0];
        const moduleParams = module.params[moduleParamName];
        if (typeof moduleParams !== 'object' || moduleParams === null) return;
        if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
        if (params[moduleParamName] === true) {
          params[moduleParamName] = { enabled: true };
        }
        if (
          typeof params[moduleParamName] === 'object'
          && !('enabled' in params[moduleParamName])
        ) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };
      }
    });

    // Extend defaults with modules params
    const swiperParams = Utils.extend({}, defaults);
    swiper.useModulesParams(swiperParams);

    // Extend defaults with passed params
    swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = Utils.extend({}, swiper.params);
    swiper.passedParams = Utils.extend({}, params);

    // Save Dom lib
    swiper.$ = __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */];

    // Find el
    const $el = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(swiper.params.el);
    el = $el[0];

    if (!el) {
      return undefined;
    }

    if ($el.length > 1) {
      const swipers = [];
      $el.each((index, containerEl) => {
        const newParams = Utils.extend({}, params, { el: containerEl });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }

    el.swiper = swiper;
    $el.data('swiper', swiper);

    // Find Wrapper
    const $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);

    // Extend Swiper
    Utils.extend(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],

      // Classes
      classNames: [],

      // Slides
      slides: Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],

      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // RTL
      rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
      wrongRTL: $wrapperEl.css('display') === '-webkit-box',

      // Indexes
      activeIndex: 0,
      realIndex: 0,

      //
      isBeginning: true,
      isEnd: false,

      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,

      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,

      // Touch Events
      touchEvents: (function touchEvents() {
        const touch = ['touchstart', 'touchmove', 'touchend'];
        let desktop = ['mousedown', 'mousemove', 'mouseup'];
        if (Support.pointerEvents) {
          desktop = ['pointerdown', 'pointermove', 'pointerup'];
        } else if (Support.prefixedPointerEvents) {
          desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
        }
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2],
        };
        return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }()),
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        formElements: 'input, select, option, textarea, button, video',
        // Last click time
        lastClickTime: Utils.now(),
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        isTouchEvent: undefined,
        startMoving: undefined,
      },

      // Clicks
      allowClick: true,

      // Touches
      allowTouchMove: swiper.params.allowTouchMove,

      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0,
      },

      // Images
      imagesToLoad: [],
      imagesLoaded: 0,

    });

    // Install Modules
    swiper.useModules();

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    return swiper;
  }

  slidesPerViewDynamic() {
    const swiper = this;
    const {
      params, slides, slidesGrid, size: swiperSize, activeIndex,
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }
    return spv;
  }

  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const { snapGrid, params } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();

    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode) {
      setTranslate();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }

  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
      return swiper;
    }

    if (currentDirection === 'vertical') {
      swiper.$el
        .removeClass(`${swiper.params.containerModifierClass}vertical wp8-vertical`)
        .addClass(`${swiper.params.containerModifierClass}${newDirection}`);

      if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
        swiper.$el.addClass(`${swiper.params.containerModifierClass}wp8-${newDirection}`);
      }
    }
    if (currentDirection === 'horizontal') {
      swiper.$el
        .removeClass(`${swiper.params.containerModifierClass}horizontal wp8-horizontal`)
        .addClass(`${swiper.params.containerModifierClass}${newDirection}`);

      if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {
        swiper.$el.addClass(`${swiper.params.containerModifierClass}wp8-${newDirection}`);
      }
    }

    swiper.params.direction = newDirection;

    swiper.slides.each((slideIndex, slideEl) => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });

    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();

    return swiper;
  }

  init() {
    const swiper = this;
    if (swiper.initialized) return;

    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();

    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }

    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }

    // Slide To Initial Slide
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
    }

    // Attach events
    swiper.attachEvents();

    // Init Flag
    swiper.initialized = true;

    // Emit
    swiper.emit('init');
  }

  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params, $el, $wrapperEl, slides,
    } = swiper;

    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }

    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr('style');
      $wrapperEl.removeAttr('style');
      if (slides && slides.length) {
        slides
          .removeClass([
            params.slideVisibleClass,
            params.slideActiveClass,
            params.slideNextClass,
            params.slidePrevClass,
          ].join(' '))
          .removeAttr('style')
          .removeAttr('data-swiper-slide-index')
          .removeAttr('data-swiper-column')
          .removeAttr('data-swiper-row');
      }
    }

    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });

    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      swiper.$el.data('swiper', null);
      Utils.deleteProps(swiper);
    }
    swiper.destroyed = true;

    return null;
  }

  static extendDefaults(newDefaults) {
    Utils.extend(extendedDefaults, newDefaults);
  }

  static get extendedDefaults() {
    return extendedDefaults;
  }

  static get defaults() {
    return defaults;
  }

  static get Class() {
    return SwiperClass;
  }

  static get $() {
    return __WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */];
  }
}

var Device$1 = {
  name: 'device',
  proto: {
    device: Device,
  },
  static: {
    device: Device,
  },
};

var Support$1 = {
  name: 'support',
  proto: {
    support: Support,
  },
  static: {
    support: Support,
  },
};

var Browser$1 = {
  name: 'browser',
  proto: {
    browser: Browser,
  },
  static: {
    browser: Browser,
  },
};

var Resize = {
  name: 'resize',
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      resize: {
        resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      // Emit resize
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].addEventListener('resize', swiper.resize.resizeHandler);

      // Emit orientationchange
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy() {
      const swiper = this;
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].removeEventListener('resize', swiper.resize.resizeHandler);
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
  },
};

const Observer = {
  func: __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].MutationObserver || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].WebkitMutationObserver,
  attach(target, options = {}) {
    const swiper = this;

    const ObserverFunc = Observer.func;
    const observer = new ObserverFunc((mutations) => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        swiper.emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        swiper.emit('observerUpdate', mutations[0]);
      };

      if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].requestAnimationFrame) {
        __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].requestAnimationFrame(observerUpdate);
      } else {
        __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].setTimeout(observerUpdate, 0);
      }
    });

    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
    });

    swiper.observer.observers.push(observer);
  },
  init() {
    const swiper = this;
    if (!Support.observer || !swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();
      for (let i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    }
    // Observe container
    swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });

    // Observe wrapper
    swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
  },
  destroy() {
    const swiper = this;
    swiper.observer.observers.forEach((observer) => {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  },
};

var Observer$1 = {
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false,
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      observer: {
        init: Observer.init.bind(swiper),
        attach: Observer.attach.bind(swiper),
        destroy: Observer.destroy.bind(swiper),
        observers: [],
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.observer.init();
    },
    destroy() {
      const swiper = this;
      swiper.observer.destroy();
    },
  },
};

const Virtual = {
  update(force) {
    const swiper = this;
    const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;
    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      renderSlide,
      offset: previousOffset,
    } = swiper.virtual;
    swiper.updateActiveIndex();
    const activeIndex = swiper.activeIndex || 0;

    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';
    else offsetProp = swiper.isHorizontal() ? 'left' : 'top';

    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
      slidesBefore = slidesPerGroup + addSlidesAfter;
    }
    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

    Utils.extend(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid,
    });

    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    }

    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.css(offsetProp, `${offset}px`);
      }
      swiper.updateProgress();
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: (function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()),
      });
      onRendered();
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    if (force) {
      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      if (i >= from && i <= to) {
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(i);
        } else {
          if (i > previousTo) appendIndexes.push(i);
          if (i < previousFrom) prependIndexes.push(i);
        }
      }
    }
    appendIndexes.forEach((index) => {
      swiper.$wrapperEl.append(renderSlide(slides[index], index));
    });
    prependIndexes.sort((a, b) => b - a).forEach((index) => {
      swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
    });
    swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
    onRendered();
  },
  renderSlide(slide, index) {
    const swiper = this;
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    const $slideEl = params.renderSlide
      ? Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(params.renderSlide.call(swiper, slide, index))
      : Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
    if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
    if (params.cache) swiper.virtual.cache[index] = $slideEl;
    return $slideEl;
  },
  appendSlide(slides) {
    const swiper = this;
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    swiper.virtual.update(true);
  },
  prependSlide(slides) {
    const swiper = this;
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;

    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach((cachedIndex) => {
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cache[cachedIndex];
      });
      swiper.virtual.cache = newCache;
    }
    swiper.virtual.update(true);
    swiper.slideTo(newActiveIndex, 0);
  },
  removeSlide(slidesIndexes) {
    const swiper = this;
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }
        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }
      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    swiper.virtual.update(true);
    swiper.slideTo(activeIndex, 0);
  },
  removeAllSlides() {
    const swiper = this;
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    swiper.virtual.update(true);
    swiper.slideTo(0, 0);
  },
};

var Virtual$1 = {
  name: 'virtual',
  params: {
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      addSlidesBefore: 0,
      addSlidesAfter: 0,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      virtual: {
        update: Virtual.update.bind(swiper),
        appendSlide: Virtual.appendSlide.bind(swiper),
        prependSlide: Virtual.prependSlide.bind(swiper),
        removeSlide: Virtual.removeSlide.bind(swiper),
        removeAllSlides: Virtual.removeAllSlides.bind(swiper),
        renderSlide: Virtual.renderSlide.bind(swiper),
        slides: swiper.params.virtual.slides,
        cache: {},
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
      const overwriteParams = {
        watchSlidesProgress: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);

      if (!swiper.params.initialSlide) {
        swiper.virtual.update();
      }
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.virtual.enabled) return;
      swiper.virtual.update();
    },
  },
};

const Keyboard = {
  handle(event) {
    const swiper = this;
    const { rtlTranslate: rtl } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    const kc = e.keyCode || e.charCode;
    // Directions locks
    if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40))) {
      return false;
    }
    if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38))) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }
    if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].activeElement && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].activeElement.nodeName && (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].activeElement.nodeName.toLowerCase() === 'input' || __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }
    if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
      let inView = false;
      // Check that swiper should be inside of visible area of window
      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }
      const windowWidth = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].innerWidth;
      const windowHeight = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].innerHeight;
      const swiperOffset = swiper.$el.offset();
      if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [
        [swiperOffset.left, swiperOffset.top],
        [swiperOffset.left + swiper.width, swiperOffset.top],
        [swiperOffset.left, swiperOffset.top + swiper.height],
        [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],
      ];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (
          point[0] >= 0 && point[0] <= windowWidth
          && point[1] >= 0 && point[1] <= windowHeight
        ) {
          inView = true;
        }
      }
      if (!inView) return undefined;
    }
    if (swiper.isHorizontal()) {
      if (kc === 37 || kc === 39) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if ((kc === 39 && !rtl) || (kc === 37 && rtl)) swiper.slideNext();
      if ((kc === 37 && !rtl) || (kc === 39 && rtl)) swiper.slidePrev();
    } else {
      if (kc === 38 || kc === 40) {
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
      }
      if (kc === 40) swiper.slideNext();
      if (kc === 38) swiper.slidePrev();
    }
    swiper.emit('keyPress', kc);
    return undefined;
  },
  enable() {
    const swiper = this;
    if (swiper.keyboard.enabled) return;
    Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */]).on('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = true;
  },
  disable() {
    const swiper = this;
    if (!swiper.keyboard.enabled) return;
    Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */]).off('keydown', swiper.keyboard.handle);
    swiper.keyboard.enabled = false;
  },
};

var Keyboard$1 = {
  name: 'keyboard',
  params: {
    keyboard: {
      enabled: false,
      onlyInViewport: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      keyboard: {
        enabled: false,
        enable: Keyboard.enable.bind(swiper),
        disable: Keyboard.disable.bind(swiper),
        handle: Keyboard.handle.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.keyboard.enabled) {
        swiper.keyboard.enable();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.keyboard.enabled) {
        swiper.keyboard.disable();
      }
    },
  },
};

function isEventSupported() {
  const eventName = 'onwheel';
  let isSupported = eventName in __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */];

  if (!isSupported) {
    const element = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported
    && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].implementation
    && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].implementation.hasFeature
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].implementation.hasFeature('', '') !== true
  ) {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}
const Mousewheel = {
  lastScrollTime: Utils.now(),
  event: (function getEvent() {
    if (__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
    return isEventSupported() ? 'wheel' : 'mousewheel';
  }()),
  normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;

    let sX = 0;
    let sY = 0; // spinX, spinY
    let pX = 0;
    let pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }

    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) { // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else { // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = (pX < 1) ? -1 : 1;
    }
    if (pY && !sY) {
      sY = (pY < 1) ? -1 : 1;
    }

    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY,
    };
  },
  handleMouseEnter() {
    const swiper = this;
    swiper.mouseEntered = true;
  },
  handleMouseLeave() {
    const swiper = this;
    swiper.mouseEntered = false;
  },
  handle(event) {
    let e = event;
    const swiper = this;
    const params = swiper.params.mousewheel;

    if (!swiper.mouseEntered && !params.releaseOnEdges) return true;

    if (e.originalEvent) e = e.originalEvent; // jquery fix
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;

    const data = Mousewheel.normalize(e);

    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;
        else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;
      else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }

    if (delta === 0) return true;

    if (params.invert) delta = -delta;

    if (!swiper.params.freeMode) {
      if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
        if (delta < 0) {
          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
            swiper.slideNext();
            swiper.emit('scroll', e);
          } else if (params.releaseOnEdges) return true;
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
          swiper.slidePrev();
          swiper.emit('scroll', e);
        } else if (params.releaseOnEdges) return true;
      }
      swiper.mousewheel.lastScrollTime = (new __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].Date()).getTime();
    } else {
      // Freemode or scrollContainer:
      if (swiper.params.loop) {
        swiper.loopFix();
      }
      let position = swiper.getTranslate() + (delta * params.sensitivity);
      const wasBeginning = swiper.isBeginning;
      const wasEnd = swiper.isEnd;

      if (position >= swiper.minTranslate()) position = swiper.minTranslate();
      if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();

      swiper.setTransition(0);
      swiper.setTranslate(position);
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();

      if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
        swiper.updateSlidesClasses();
      }

      if (swiper.params.freeModeSticky) {
        clearTimeout(swiper.mousewheel.timeout);
        swiper.mousewheel.timeout = Utils.nextTick(() => {
          swiper.slideToClosest();
        }, 300);
      }
      // Emit event
      swiper.emit('scroll', e);

      // Stop autoplay
      if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
      // Return page scroll on edge positions
      if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
    }

    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    return false;
  },
  enable() {
    const swiper = this;
    if (!Mousewheel.event) return false;
    if (swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(swiper.params.mousewheel.eventsTarged);
    }
    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
    target.on(Mousewheel.event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = true;
    return true;
  },
  disable() {
    const swiper = this;
    if (!Mousewheel.event) return false;
    if (!swiper.mousewheel.enabled) return false;
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarged !== 'container') {
      target = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(swiper.params.mousewheel.eventsTarged);
    }
    target.off(Mousewheel.event, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = false;
    return true;
  },
};

var Mousewheel$1 = {
  name: 'mousewheel',
  params: {
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarged: 'container',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      mousewheel: {
        enabled: false,
        enable: Mousewheel.enable.bind(swiper),
        disable: Mousewheel.disable.bind(swiper),
        handle: Mousewheel.handle.bind(swiper),
        handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
        handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
        lastScrollTime: Utils.now(),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
    },
    destroy() {
      const swiper = this;
      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
    },
  },
};

const Navigation = {
  update() {
    // Update Navigation Buttons
    const swiper = this;
    const params = swiper.params.navigation;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        $prevEl.addClass(params.disabledClass);
      } else {
        $prevEl.removeClass(params.disabledClass);
      }
      $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        $nextEl.addClass(params.disabledClass);
      } else {
        $nextEl.removeClass(params.disabledClass);
      }
      $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    }
  },
  onPrevClick(e) {
    const swiper = this;
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop) return;
    swiper.slidePrev();
  },
  onNextClick(e) {
    const swiper = this;
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop) return;
    swiper.slideNext();
  },
  init() {
    const swiper = this;
    const params = swiper.params.navigation;
    if (!(params.nextEl || params.prevEl)) return;

    let $nextEl;
    let $prevEl;
    if (params.nextEl) {
      $nextEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(params.nextEl);
      if (
        swiper.params.uniqueNavElements
        && typeof params.nextEl === 'string'
        && $nextEl.length > 1
        && swiper.$el.find(params.nextEl).length === 1
      ) {
        $nextEl = swiper.$el.find(params.nextEl);
      }
    }
    if (params.prevEl) {
      $prevEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(params.prevEl);
      if (
        swiper.params.uniqueNavElements
        && typeof params.prevEl === 'string'
        && $prevEl.length > 1
        && swiper.$el.find(params.prevEl).length === 1
      ) {
        $prevEl = swiper.$el.find(params.prevEl);
      }
    }

    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on('click', swiper.navigation.onNextClick);
    }
    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on('click', swiper.navigation.onPrevClick);
    }

    Utils.extend(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0],
    });
  },
  destroy() {
    const swiper = this;
    const { $nextEl, $prevEl } = swiper.navigation;
    if ($nextEl && $nextEl.length) {
      $nextEl.off('click', swiper.navigation.onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }
    if ($prevEl && $prevEl.length) {
      $prevEl.off('click', swiper.navigation.onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  },
};

var Navigation$1 = {
  name: 'navigation',
  params: {
    navigation: {
      nextEl: null,
      prevEl: null,

      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      navigation: {
        init: Navigation.init.bind(swiper),
        update: Navigation.update.bind(swiper),
        destroy: Navigation.destroy.bind(swiper),
        onNextClick: Navigation.onNextClick.bind(swiper),
        onPrevClick: Navigation.onPrevClick.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.navigation.init();
      swiper.navigation.update();
    },
    toEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    fromEdge() {
      const swiper = this;
      swiper.navigation.update();
    },
    destroy() {
      const swiper = this;
      swiper.navigation.destroy();
    },
    click(e) {
      const swiper = this;
      const { $nextEl, $prevEl } = swiper.navigation;
      if (
        swiper.params.navigation.hideOnClick
        && !Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(e.target).is($prevEl)
        && !Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(e.target).is($nextEl)
      ) {
        let isHidden;
        if ($nextEl) {
          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
        } else if ($prevEl) {
          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
        }
        if (isHidden === true) {
          swiper.emit('navigationShow', swiper);
        } else {
          swiper.emit('navigationHide', swiper);
        }
        if ($nextEl) {
          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
        if ($prevEl) {
          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
        }
      }
    },
  },
};

const Pagination = {
  update() {
    // Render || Update Pagination bullets/items
    const swiper = this;
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    // Current/Total
    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
      if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
        current -= (slidesLength - (swiper.loopedSlides * 2));
      }
      if (current > total - 1) current -= total;
      if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
        $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);
        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
          swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
          if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
            swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (swiper.pagination.dynamicBulletIndex < 0) {
            swiper.pagination.dynamicBulletIndex = 0;
          }
        }
        firstIndex = current - swiper.pagination.dynamicBulletIndex;
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);
      if ($el.length > 1) {
        bullets.each((index, bullet) => {
          const $bullet = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(bullet);
          const bulletIndex = $bullet.index();
          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }
            if (bulletIndex === firstIndex) {
              $bullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
            }
            if (bulletIndex === lastIndex) {
              $bullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        $bullet.addClass(params.bulletActiveClass);
        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
          }
          $firstDisplayedBullet
            .prev()
            .addClass(`${params.bulletActiveClass}-prev`)
            .prev()
            .addClass(`${params.bulletActiveClass}-prev-prev`);
          $lastDisplayedBullet
            .next()
            .addClass(`${params.bulletActiveClass}-next`)
            .next()
            .addClass(`${params.bulletActiveClass}-next-next`);
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
        const offsetProp = rtl ? 'right' : 'left';
        bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
      }
    }
    if (params.type === 'fraction') {
      $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));
      $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));
    }
    if (params.type === 'progressbar') {
      let progressbarDirection;
      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
      } else {
        progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
      }
      const scale = (current + 1) / total;
      let scaleX = 1;
      let scaleY = 1;
      if (progressbarDirection === 'horizontal') {
        scaleX = scale;
      } else {
        scaleY = scale;
      }
      $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }
    if (params.type === 'custom' && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      swiper.emit('paginationRender', swiper, $el[0]);
    } else {
      swiper.emit('paginationUpdate', swiper, $el[0]);
    }
    $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
  },
  render() {
    // Render Container
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

    const $el = swiper.pagination.$el;
    let paginationHTML = '';
    if (params.type === 'bullets') {
      const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>`
        + ' / '
        + `<span class="${params.totalClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type !== 'custom') {
      swiper.emit('paginationRender', swiper.pagination.$el[0]);
    }
  },
  init() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el) return;

    let $el = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(params.el);
    if ($el.length === 0) return;

    if (
      swiper.params.uniqueNavElements
      && typeof params.el === 'string'
      && $el.length > 1
      && swiper.$el.find(params.el).length === 1
    ) {
      $el = swiper.$el.find(params.el);
    }

    if (params.type === 'bullets' && params.clickable) {
      $el.addClass(params.clickableClass);
    }

    $el.addClass(params.modifierClass + params.type);

    if (params.type === 'bullets' && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      swiper.pagination.dynamicBulletIndex = 0;
      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }
    if (params.type === 'progressbar' && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }

    if (params.clickable) {
      $el.on('click', `.${params.bulletClass}`, function onClick(e) {
        e.preventDefault();
        let index = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop) index += swiper.loopedSlides;
        swiper.slideTo(index);
      });
    }

    Utils.extend(swiper.pagination, {
      $el,
      el: $el[0],
    });
  },
  destroy() {
    const swiper = this;
    const params = swiper.params.pagination;
    if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
    const $el = swiper.pagination.$el;

    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
    if (params.clickable) {
      $el.off('click', `.${params.bulletClass}`);
    }
  },
};

var Pagination$1 = {
  name: 'pagination',
  params: {
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: number => number,
      formatFractionTotal: number => number,
      bulletClass: 'swiper-pagination-bullet',
      bulletActiveClass: 'swiper-pagination-bullet-active',
      modifierClass: 'swiper-pagination-', // NEW
      currentClass: 'swiper-pagination-current',
      totalClass: 'swiper-pagination-total',
      hiddenClass: 'swiper-pagination-hidden',
      progressbarFillClass: 'swiper-pagination-progressbar-fill',
      progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
      clickableClass: 'swiper-pagination-clickable', // NEW
      lockClass: 'swiper-pagination-lock',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      pagination: {
        init: Pagination.init.bind(swiper),
        render: Pagination.render.bind(swiper),
        update: Pagination.update.bind(swiper),
        destroy: Pagination.destroy.bind(swiper),
        dynamicBulletIndex: 0,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.pagination.init();
      swiper.pagination.render();
      swiper.pagination.update();
    },
    activeIndexChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.update();
      } else if (typeof swiper.snapIndex === 'undefined') {
        swiper.pagination.update();
      }
    },
    snapIndexChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.update();
      }
    },
    slidesLengthChange() {
      const swiper = this;
      if (swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    snapGridLengthChange() {
      const swiper = this;
      if (!swiper.params.loop) {
        swiper.pagination.render();
        swiper.pagination.update();
      }
    },
    destroy() {
      const swiper = this;
      swiper.pagination.destroy();
    },
    click(e) {
      const swiper = this;
      if (
        swiper.params.pagination.el
        && swiper.params.pagination.hideOnClick
        && swiper.pagination.$el.length > 0
        && !Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(e.target).hasClass(swiper.params.pagination.bulletClass)
      ) {
        const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
        if (isHidden === true) {
          swiper.emit('paginationShow', swiper);
        } else {
          swiper.emit('paginationHide', swiper);
        }
        swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
      }
    },
  },
};

const Scrollbar = {
  setTranslate() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const { scrollbar, rtlTranslate: rtl, progress } = swiper;
    const {
      dragSize, trackSize, $dragEl, $el,
    } = scrollbar;
    const params = swiper.params.scrollbar;

    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      if (Support.transforms3d) {
        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      } else {
        $dragEl.transform(`translateX(${newPos}px)`);
      }
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      if (Support.transforms3d) {
        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      } else {
        $dragEl.transform(`translateY(${newPos}px)`);
      }
      $dragEl[0].style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(swiper.scrollbar.timeout);
      $el[0].style.opacity = 1;
      swiper.scrollbar.timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1000);
    }
  },
  setTransition(duration) {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.$dragEl.transition(duration);
  },
  updateSize() {
    const swiper = this;
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;

    const { scrollbar } = swiper;
    const { $dragEl, $el } = scrollbar;

    $dragEl[0].style.width = '';
    $dragEl[0].style.height = '';
    const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

    const divider = swiper.size / swiper.virtualSize;
    const moveDivider = divider * (trackSize / swiper.size);
    let dragSize;
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }

    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }

    if (divider >= 1) {
      $el[0].style.display = 'none';
    } else {
      $el[0].style.display = '';
    }
    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }
    Utils.extend(scrollbar, {
      trackSize,
      divider,
      moveDivider,
      dragSize,
    });
    scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
  },
  setDragPosition(e) {
    const swiper = this;
    const { scrollbar, rtlTranslate: rtl } = swiper;
    const { $el, dragSize, trackSize } = scrollbar;

    let pointerPosition;
    if (swiper.isHorizontal()) {
      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);
    } else {
      pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
    }
    let positionRatio;
    positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }

    const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  },
  onDragStart(e) {
    const swiper = this;
    const params = swiper.params.scrollbar;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;
    swiper.scrollbar.isTouched = true;
    e.preventDefault();
    e.stopPropagation();

    $wrapperEl.transition(100);
    $dragEl.transition(100);
    scrollbar.setDragPosition(e);

    clearTimeout(swiper.scrollbar.dragTimeout);

    $el.transition(0);
    if (params.hide) {
      $el.css('opacity', 1);
    }
    swiper.emit('scrollbarDragStart', e);
  },
  onDragMove(e) {
    const swiper = this;
    const { scrollbar, $wrapperEl } = swiper;
    const { $el, $dragEl } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
    scrollbar.setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    swiper.emit('scrollbarDragMove', e);
  },
  onDragEnd(e) {
    const swiper = this;

    const params = swiper.params.scrollbar;
    const { scrollbar } = swiper;
    const { $el } = scrollbar;

    if (!swiper.scrollbar.isTouched) return;
    swiper.scrollbar.isTouched = false;
    if (params.hide) {
      clearTimeout(swiper.scrollbar.dragTimeout);
      swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
        $el.css('opacity', 0);
        $el.transition(400);
      }, 1000);
    }
    swiper.emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  },
  enableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEventsTouch, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
    if (!Support.touch) {
      target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  disableDraggable() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const {
      scrollbar, touchEventsTouch, touchEventsDesktop, params,
    } = swiper;
    const $el = scrollbar.$el;
    const target = $el[0];
    const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
    const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
    if (!Support.touch) {
      target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
    } else {
      target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
      target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
      target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.scrollbar.el) return;
    const { scrollbar, $el: $swiperEl } = swiper;
    const params = swiper.params.scrollbar;

    let $el = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(params.el);
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }

    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
    if ($dragEl.length === 0) {
      $dragEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }

    Utils.extend(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0],
    });

    if (params.draggable) {
      scrollbar.enableDraggable();
    }
  },
  destroy() {
    const swiper = this;
    swiper.scrollbar.disableDraggable();
  },
};

var Scrollbar$1 = {
  name: 'scrollbar',
  params: {
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      scrollbar: {
        init: Scrollbar.init.bind(swiper),
        destroy: Scrollbar.destroy.bind(swiper),
        updateSize: Scrollbar.updateSize.bind(swiper),
        setTranslate: Scrollbar.setTranslate.bind(swiper),
        setTransition: Scrollbar.setTransition.bind(swiper),
        enableDraggable: Scrollbar.enableDraggable.bind(swiper),
        disableDraggable: Scrollbar.disableDraggable.bind(swiper),
        setDragPosition: Scrollbar.setDragPosition.bind(swiper),
        onDragStart: Scrollbar.onDragStart.bind(swiper),
        onDragMove: Scrollbar.onDragMove.bind(swiper),
        onDragEnd: Scrollbar.onDragEnd.bind(swiper),
        isTouched: false,
        timeout: null,
        dragTimeout: null,
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      swiper.scrollbar.init();
      swiper.scrollbar.updateSize();
      swiper.scrollbar.setTranslate();
    },
    update() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    resize() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    observerUpdate() {
      const swiper = this;
      swiper.scrollbar.updateSize();
    },
    setTranslate() {
      const swiper = this;
      swiper.scrollbar.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      swiper.scrollbar.setTransition(duration);
    },
    destroy() {
      const swiper = this;
      swiper.scrollbar.destroy();
    },
  },
};

const Parallax = {
  setTransform(el, progress) {
    const swiper = this;
    const { rtl } = swiper;

    const $el = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(el);
    const rtlFactor = rtl ? -1 : 1;

    const p = $el.attr('data-swiper-parallax') || '0';
    let x = $el.attr('data-swiper-parallax-x');
    let y = $el.attr('data-swiper-parallax-y');
    const scale = $el.attr('data-swiper-parallax-scale');
    const opacity = $el.attr('data-swiper-parallax-opacity');

    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }

    if ((x).indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if ((y).indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }

    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
      $el[0].style.opacity = currentOpacity;
    }
    if (typeof scale === 'undefined' || scale === null) {
      $el.transform(`translate3d(${x}, ${y}, 0px)`);
    } else {
      const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
    }
  },
  setTranslate() {
    const swiper = this;
    const {
      $el, slides, progress, snapGrid,
    } = swiper;
    $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
      .each((index, el) => {
        swiper.parallax.setTransform(el, progress);
      });
    slides.each((slideIndex, slideEl) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
        .each((index, el) => {
          swiper.parallax.setTransform(el, slideProgress);
        });
    });
  },
  setTransition(duration = this.params.speed) {
    const swiper = this;
    const { $el } = swiper;
    $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')
      .each((index, parallaxEl) => {
        const $parallaxEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(parallaxEl);
        let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
        if (duration === 0) parallaxDuration = 0;
        $parallaxEl.transition(parallaxDuration);
      });
  },
};

var Parallax$1 = {
  name: 'parallax',
  params: {
    parallax: {
      enabled: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      parallax: {
        setTransform: Parallax.setTransform.bind(swiper),
        setTranslate: Parallax.setTranslate.bind(swiper),
        setTransition: Parallax.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    init() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTranslate() {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (!swiper.params.parallax.enabled) return;
      swiper.parallax.setTransition(duration);
    },
  },
};

const Zoom = {
  // Calc Scale From Multi-touches
  getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2) return 1;
    const x1 = e.targetTouches[0].pageX;
    const y1 = e.targetTouches[0].pageY;
    const x2 = e.targetTouches[1].pageX;
    const y2 = e.targetTouches[1].pageY;
    const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));
    return distance;
  },
  // Events
  onGestureStart(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    zoom.fakeGestureTouched = false;
    zoom.fakeGestureMoved = false;
    if (!Support.gestures) {
      if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureTouched = true;
      gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(e.target).closest('.swiper-slide');
      if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = undefined;
        return;
      }
    }
    gesture.$imageEl.transition(0);
    swiper.zoom.isScaling = true;
  },
  onGestureChange(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
        return;
      }
      zoom.fakeGestureMoved = true;
      gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (Support.gestures) {
      zoom.scale = e.scale * zoom.currentScale;
    } else {
      zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
    }
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);
    }
    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  onGestureEnd(e) {
    const swiper = this;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (!Support.gestures) {
      if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
        return;
      }
      if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
        return;
      }
      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    zoom.currentScale = zoom.scale;
    zoom.isScaling = false;
    if (zoom.scale === 1) gesture.$slideEl = undefined;
  },
  onTouchStart(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (image.isTouched) return;
    if (Device.android) e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  },
  onTouchMove(e) {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl) return;

    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
      image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
      if (swiper.rtl) {
        image.startX = -image.startX;
        image.startY = -image.startY;
      }
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;

    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;

    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;

    image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

    if (!image.isMoved && !zoom.isScaling) {
      if (
        swiper.isHorizontal()
        && (
          (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
          || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
        )
      ) {
        image.isTouched = false;
        return;
      } if (
        !swiper.isHorizontal()
        && (
          (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
          || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
        )
      ) {
        image.isTouched = false;
        return;
      }
    }
    e.preventDefault();
    e.stopPropagation();

    image.isMoved = true;
    image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
    image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

    if (image.currentX < image.minX) {
      image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);
    }
    if (image.currentX > image.maxX) {
      image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);
    }

    if (image.currentY < image.minY) {
      image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);
    }
    if (image.currentY > image.maxY) {
      image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();

    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTouchEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture, image, velocity } = zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);

    image.currentX = newPositionX;
    image.currentY = newPositionY;

    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
    image.maxX = -image.minX;
    image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  },
  onTransitionEnd() {
    const swiper = this;
    const zoom = swiper.zoom;
    const { gesture } = zoom;
    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
      gesture.$imageWrapEl.transform('translate3d(0,0,0)');

      zoom.scale = 1;
      zoom.currentScale = 1;

      gesture.$slideEl = undefined;
      gesture.$imageEl = undefined;
      gesture.$imageWrapEl = undefined;
    }
  },
  // Toggle Zoom
  toggle(e) {
    const swiper = this;
    const zoom = swiper.zoom;

    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoom.out();
    } else {
      // Zoom In
      zoom.in(e);
    }
  },
  in(e) {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture, image } = zoom;

    if (!gesture.$slideEl) {
      gesture.$slideEl = swiper.clickedSlide ? Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);

    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;

    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }

    zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left;
      offsetY = gesture.$slideEl.offset().top;
      diffX = (offsetX + (slideWidth / 2)) - touchX;
      diffY = (offsetY + (slideHeight / 2)) - touchY;

      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;

      translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
      translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;

      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;

      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }

      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  },
  out() {
    const swiper = this;

    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    const { gesture } = zoom;

    if (!gesture.$slideEl) {
      gesture.$slideEl = swiper.clickedSlide ? Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

    zoom.scale = 1;
    zoom.currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
    gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
    gesture.$slideEl = undefined;
  },
  // Attach/Detach Events
  enable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

    // Scale image
    if (Support.gestures) {
      swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
    }

    // Move image
    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);
  },
  disable() {
    const swiper = this;
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;

    swiper.zoom.enabled = false;

    const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;

    // Scale image
    if (Support.gestures) {
      swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);
    } else if (swiper.touchEvents.start === 'touchstart') {
      swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);
    }

    // Move image
    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove);
  },
};

var Zoom$1 = {
  name: 'zoom',
  params: {
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed',
    },
  },
  create() {
    const swiper = this;
    const zoom = {
      enabled: false,
      scale: 1,
      currentScale: 1,
      isScaling: false,
      gesture: {
        $slideEl: undefined,
        slideWidth: undefined,
        slideHeight: undefined,
        $imageEl: undefined,
        $imageWrapEl: undefined,
        maxRatio: 3,
      },
      image: {
        isTouched: undefined,
        isMoved: undefined,
        currentX: undefined,
        currentY: undefined,
        minX: undefined,
        minY: undefined,
        maxX: undefined,
        maxY: undefined,
        width: undefined,
        height: undefined,
        startX: undefined,
        startY: undefined,
        touchesStart: {},
        touchesCurrent: {},
      },
      velocity: {
        x: undefined,
        y: undefined,
        prevPositionX: undefined,
        prevPositionY: undefined,
        prevTime: undefined,
      },
    };

    ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {
      zoom[methodName] = Zoom[methodName].bind(swiper);
    });
    Utils.extend(swiper, {
      zoom,
    });

    let scale = 1;
    Object.defineProperty(swiper.zoom, 'scale', {
      get() {
        return scale;
      },
      set(value) {
        if (scale !== value) {
          const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
          const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
          swiper.emit('zoomChange', value, imageEl, slideEl);
        }
        scale = value;
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.zoom.enabled) {
        swiper.zoom.enable();
      }
    },
    destroy() {
      const swiper = this;
      swiper.zoom.disable();
    },
    touchStart(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchStart(e);
    },
    touchEnd(e) {
      const swiper = this;
      if (!swiper.zoom.enabled) return;
      swiper.zoom.onTouchEnd(e);
    },
    doubleTap(e) {
      const swiper = this;
      if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
        swiper.zoom.toggle(e);
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
        swiper.zoom.onTransitionEnd();
      }
    },
  },
};

const Lazy = {
  loadInSlide(index, loadInDuplicate = true) {
    const swiper = this;
    const params = swiper.params.lazy;
    if (typeof index === 'undefined') return;
    if (swiper.slides.length === 0) return;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

    const $slideEl = isVirtual
      ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`)
      : swiper.slides.eq(index);

    let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images = $images.add($slideEl[0]);
    }
    if ($images.length === 0) return;

    $images.each((imageIndex, imageEl) => {
      const $imageEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(imageEl);
      $imageEl.addClass(params.loadingClass);

      const background = $imageEl.attr('data-background');
      const src = $imageEl.attr('data-src');
      const srcset = $imageEl.attr('data-srcset');
      const sizes = $imageEl.attr('data-sizes');

      swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;
        if (background) {
          $imageEl.css('background-image', `url("${background}")`);
          $imageEl.removeAttr('data-background');
        } else {
          if (srcset) {
            $imageEl.attr('srcset', srcset);
            $imageEl.removeAttr('data-srcset');
          }
          if (sizes) {
            $imageEl.attr('sizes', sizes);
            $imageEl.removeAttr('data-sizes');
          }
          if (src) {
            $imageEl.attr('src', src);
            $imageEl.removeAttr('data-src');
          }
        }

        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(`.${params.preloaderClass}`).remove();
        if (swiper.params.loop && loadInDuplicate) {
          const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
            swiper.lazy.loadInSlide(originalSlide.index(), false);
          } else {
            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
            swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
          }
        }
        swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
      });

      swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
    });
  },
  load() {
    const swiper = this;
    const {
      $wrapperEl, params: swiperParams, slides, activeIndex,
    } = swiper;
    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    const params = swiperParams.lazy;

    let slidesPerView = swiperParams.slidesPerView;
    if (slidesPerView === 'auto') {
      slidesPerView = 0;
    }

    function slideExist(index) {
      if (isVirtual) {
        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
          return true;
        }
      } else if (slides[index]) return true;
      return false;
    }
    function slideIndex(slideEl) {
      if (isVirtual) {
        return Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(slideEl).attr('data-swiper-slide-index');
      }
      return Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(slideEl).index();
    }

    if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
    if (swiper.params.watchSlidesVisibility) {
      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {
        const index = isVirtual ? Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(slideEl).attr('data-swiper-slide-index') : Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(slideEl).index();
        swiper.lazy.loadInSlide(index);
      });
    } else if (slidesPerView > 1) {
      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i)) swiper.lazy.loadInSlide(i);
      }
    } else {
      swiper.lazy.loadInSlide(activeIndex);
    }
    if (params.loadPrevNext) {
      if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
        const amount = params.loadPrevNextAmount;
        const spv = slidesPerView;
        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
        // Next Slides
        for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
        // Prev Slides
        for (let i = minIndex; i < activeIndex; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
      } else {
        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
        if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));

        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
        if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
      }
    }
  },
};

var Lazy$1 = {
  name: 'lazy',
  params: {
    lazy: {
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,

      elementClass: 'swiper-lazy',
      loadingClass: 'swiper-lazy-loading',
      loadedClass: 'swiper-lazy-loaded',
      preloaderClass: 'swiper-lazy-preloader',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      lazy: {
        initialImageLoaded: false,
        load: Lazy.load.bind(swiper),
        loadInSlide: Lazy.loadInSlide.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
        swiper.params.preloadImages = false;
      }
    },
    init() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
        swiper.lazy.load();
      }
    },
    scroll() {
      const swiper = this;
      if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
        swiper.lazy.load();
      }
    },
    resize() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    scrollbarDragMove() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
    },
    transitionStart() {
      const swiper = this;
      if (swiper.params.lazy.enabled) {
        if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
          swiper.lazy.load();
        }
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
        swiper.lazy.load();
      }
    },
  },
};

/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

const Controller = {
  LinearSpline: function LinearSpline(x, y) {
    const binarySearch = (function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }());
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;

    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
      return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
    };
    return this;
  },
  // xxx: for now i will just save one spline function to to
  getInterpolateFunction(c) {
    const swiper = this;
    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop
        ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
        : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  },
  setTranslate(setTranslate, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    function setControlledTranslate(c) {
      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        swiper.controller.getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }

      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
      }

      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  },
  setTransition(duration, byController) {
    const swiper = this;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        if (c.params.autoHeight) {
          Utils.nextTick(() => {
            c.updateAutoHeight();
          });
        }
        c.$wrapperEl.transitionEnd(() => {
          if (!controlled) return;
          if (c.params.loop && swiper.params.controller.by === 'slide') {
            c.loopFix();
          }
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  },
};
var Controller$1 = {
  name: 'controller',
  params: {
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide', // or 'container'
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      controller: {
        control: swiper.params.controller.control,
        getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
        setTranslate: Controller.setTranslate.bind(swiper),
        setTransition: Controller.setTransition.bind(swiper),
      },
    });
  },
  on: {
    update() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    resize() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.controller.control) return;
      if (swiper.controller.spline) {
        swiper.controller.spline = undefined;
        delete swiper.controller.spline;
      }
    },
    setTranslate(translate, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTranslate(translate, byController);
    },
    setTransition(duration, byController) {
      const swiper = this;
      if (!swiper.controller.control) return;
      swiper.controller.setTransition(duration, byController);
    },
  },
};

const a11y = {
  makeElFocusable($el) {
    $el.attr('tabIndex', '0');
    return $el;
  },
  addElRole($el, role) {
    $el.attr('role', role);
    return $el;
  },
  addElLabel($el, label) {
    $el.attr('aria-label', label);
    return $el;
  },
  disableEl($el) {
    $el.attr('aria-disabled', true);
    return $el;
  },
  enableEl($el) {
    $el.attr('aria-disabled', false);
    return $el;
  },
  onEnterKey(e) {
    const swiper = this;
    const params = swiper.params.a11y;
    if (e.keyCode !== 13) return;
    const $targetEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(e.target);
    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }
      if (swiper.isEnd) {
        swiper.a11y.notify(params.lastSlideMessage);
      } else {
        swiper.a11y.notify(params.nextSlideMessage);
      }
    }
    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }
      if (swiper.isBeginning) {
        swiper.a11y.notify(params.firstSlideMessage);
      } else {
        swiper.a11y.notify(params.prevSlideMessage);
      }
    }
    if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {
      $targetEl[0].click();
    }
  },
  notify(message) {
    const swiper = this;
    const notification = swiper.a11y.liveRegion;
    if (notification.length === 0) return;
    notification.html('');
    notification.html(message);
  },
  updateNavigation() {
    const swiper = this;

    if (swiper.params.loop) return;
    const { $nextEl, $prevEl } = swiper.navigation;

    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        swiper.a11y.disableEl($prevEl);
      } else {
        swiper.a11y.enableEl($prevEl);
      }
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        swiper.a11y.disableEl($nextEl);
      } else {
        swiper.a11y.enableEl($nextEl);
      }
    }
  },
  updatePagination() {
    const swiper = this;
    const params = swiper.params.a11y;
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.bullets.each((bulletIndex, bulletEl) => {
        const $bulletEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(bulletEl);
        swiper.a11y.makeElFocusable($bulletEl);
        swiper.a11y.addElRole($bulletEl, 'button');
        swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
      });
    }
  },
  init() {
    const swiper = this;

    swiper.$el.append(swiper.a11y.liveRegion);

    // Navigation
    const params = swiper.params.a11y;
    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      swiper.a11y.makeElFocusable($nextEl);
      swiper.a11y.addElRole($nextEl, 'button');
      swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
      $nextEl.on('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      swiper.a11y.makeElFocusable($prevEl);
      swiper.a11y.addElRole($prevEl, 'button');
      swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
      $prevEl.on('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();

    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      $nextEl.off('keydown', swiper.a11y.onEnterKey);
    }
    if ($prevEl) {
      $prevEl.off('keydown', swiper.a11y.onEnterKey);
    }

    // Pagination
    if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
      swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
    }
  },
};
var A11y = {
  name: 'a11y',
  params: {
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      a11y: {
        liveRegion: Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`),
      },
    });
    Object.keys(a11y).forEach((methodName) => {
      swiper.a11y[methodName] = a11y[methodName].bind(swiper);
    });
  },
  on: {
    init() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.init();
      swiper.a11y.updateNavigation();
    },
    toEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    fromEdge() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updateNavigation();
    },
    paginationUpdate() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.updatePagination();
    },
    destroy() {
      const swiper = this;
      if (!swiper.params.a11y.enabled) return;
      swiper.a11y.destroy();
    },
  },
};

const History = {
  init() {
    const swiper = this;
    if (!swiper.params.history) return;
    if (!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].history || !__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    const history = swiper.history;
    history.initialized = true;
    history.paths = History.getPathValues();
    if (!history.paths.key && !history.paths.value) return;
    history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].addEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  destroy() {
    const swiper = this;
    if (!swiper.params.history.replaceState) {
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].removeEventListener('popstate', swiper.history.setHistoryPopState);
    }
  },
  setHistoryPopState() {
    const swiper = this;
    swiper.history.paths = History.getPathValues();
    swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
  },
  getPathValues() {
    const pathArray = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].location.pathname.slice(1).split('/').filter(part => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return { key, value };
  },
  setHistory(key, index) {
    const swiper = this;
    if (!swiper.history.initialized || !swiper.params.history.enabled) return;
    const slide = swiper.slides.eq(index);
    let value = History.slugify(slide.attr('data-history'));
    if (!__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].location.pathname.includes(key)) {
      value = `${key}/${value}`;
    }
    const currentState = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].history.replaceState({ value }, null, value);
    } else {
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].history.pushState({ value }, null, value);
    }
  },
  slugify(text) {
    return text.toString()
      .replace(/\s+/g, '-')
      .replace(/[^\w-]+/g, '')
      .replace(/--+/g, '-')
      .replace(/^-+/, '')
      .replace(/-+$/, '');
  },
  scrollToSlide(speed, value, runCallbacks) {
    const swiper = this;
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHistory = History.slugify(slide.attr('data-history'));
        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  },
};

var History$1 = {
  name: 'history',
  params: {
    history: {
      enabled: false,
      replaceState: false,
      key: 'slides',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      history: {
        init: History.init.bind(swiper),
        setHistory: History.setHistory.bind(swiper),
        setHistoryPopState: History.setHistoryPopState.bind(swiper),
        scrollToSlide: History.scrollToSlide.bind(swiper),
        destroy: History.destroy.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.history.enabled) {
        swiper.history.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.history.initialized) {
        swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
      }
    },
  },
};

const HashNavigation = {
  onHashCange() {
    const swiper = this;
    const newHash = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].location.hash.replace('#', '');
    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
      if (typeof newIndex === 'undefined') return;
      swiper.slideTo(newIndex);
    }
  },
  setHash() {
    const swiper = this;
    if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) return;
    if (swiper.params.hashNavigation.replaceState && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].history && __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].history.replaceState) {
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */].history.replaceState(null, null, (`#${swiper.slides.eq(swiper.activeIndex).attr('data-hash')}` || ''));
    } else {
      const slide = swiper.slides.eq(swiper.activeIndex);
      const hash = slide.attr('data-hash') || slide.attr('data-history');
      __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].location.hash = hash || '';
    }
  },
  init() {
    const swiper = this;
    if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) return;
    swiper.hashNavigation.initialized = true;
    const hash = __WEBPACK_IMPORTED_MODULE_1_ssr_window__["a" /* document */].location.hash.replace('#', '');
    if (hash) {
      const speed = 0;
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHash = slide.attr('data-hash') || slide.attr('data-history');
        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index = slide.index();
          swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }
    if (swiper.params.hashNavigation.watchState) {
      Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */]).on('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
  destroy() {
    const swiper = this;
    if (swiper.params.hashNavigation.watchState) {
      Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(__WEBPACK_IMPORTED_MODULE_1_ssr_window__["b" /* window */]).off('hashchange', swiper.hashNavigation.onHashCange);
    }
  },
};
var HashNavigation$1 = {
  name: 'hash-navigation',
  params: {
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      hashNavigation: {
        initialized: false,
        init: HashNavigation.init.bind(swiper),
        destroy: HashNavigation.destroy.bind(swiper),
        setHash: HashNavigation.setHash.bind(swiper),
        onHashCange: HashNavigation.onHashCange.bind(swiper),
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.init();
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.params.hashNavigation.enabled) {
        swiper.hashNavigation.destroy();
      }
    },
    transitionEnd() {
      const swiper = this;
      if (swiper.hashNavigation.initialized) {
        swiper.hashNavigation.setHash();
      }
    },
  },
};

/* eslint no-underscore-dangle: "off" */

const Autoplay = {
  run() {
    const swiper = this;
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;
    if ($activeSlideEl.attr('data-swiper-autoplay')) {
      delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
    }
    swiper.autoplay.timeout = Utils.nextTick(() => {
      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isBeginning) {
          swiper.slidePrev(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.isEnd) {
        swiper.slideNext(swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        swiper.slideTo(0, swiper.params.speed, true, true);
        swiper.emit('autoplay');
      } else {
        swiper.autoplay.stop();
      }
    }, delay);
  },
  start() {
    const swiper = this;
    if (typeof swiper.autoplay.timeout !== 'undefined') return false;
    if (swiper.autoplay.running) return false;
    swiper.autoplay.running = true;
    swiper.emit('autoplayStart');
    swiper.autoplay.run();
    return true;
  },
  stop() {
    const swiper = this;
    if (!swiper.autoplay.running) return false;
    if (typeof swiper.autoplay.timeout === 'undefined') return false;

    if (swiper.autoplay.timeout) {
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = undefined;
    }
    swiper.autoplay.running = false;
    swiper.emit('autoplayStop');
    return true;
  },
  pause(speed) {
    const swiper = this;
    if (!swiper.autoplay.running) return;
    if (swiper.autoplay.paused) return;
    if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
    swiper.autoplay.paused = true;
    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      swiper.autoplay.run();
    } else {
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
    }
  },
};

var Autoplay$1 = {
  name: 'autoplay',
  params: {
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      autoplay: {
        running: false,
        paused: false,
        run: Autoplay.run.bind(swiper),
        start: Autoplay.start.bind(swiper),
        stop: Autoplay.stop.bind(swiper),
        pause: Autoplay.pause.bind(swiper),
        onTransitionEnd(e) {
          if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
          swiper.autoplay.paused = false;
          if (!swiper.autoplay.running) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.run();
          }
        },
      },
    });
  },
  on: {
    init() {
      const swiper = this;
      if (swiper.params.autoplay.enabled) {
        swiper.autoplay.start();
      }
    },
    beforeTransitionStart(speed, internal) {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.pause(speed);
        } else {
          swiper.autoplay.stop();
        }
      }
    },
    sliderFirstMove() {
      const swiper = this;
      if (swiper.autoplay.running) {
        if (swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.stop();
        } else {
          swiper.autoplay.pause();
        }
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.autoplay.running) {
        swiper.autoplay.stop();
      }
    },
  },
};

const Fade = {
  setTranslate() {
    const swiper = this;
    const { slides } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset = $slideEl[0].swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade
        ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
        : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      $slideEl
        .css({
          opacity: slideOpacity,
        })
        .transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, $wrapperEl } = swiper;
    slides.transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      slides.transitionEnd(() => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFade = {
  name: 'effect-fade',
  params: {
    fadeEffect: {
      crossFade: false,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      fadeEffect: {
        setTranslate: Fade.setTranslate.bind(swiper),
        setTransition: Fade.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'fade') return;
      swiper.fadeEffect.setTransition(duration);
    },
  },
};

const Cube = {
  setTranslate() {
    const swiper = this;
    const {
      $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let $cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }
        $cubeShadowEl.css({ height: `${swiperWidth}px` });
      } else {
        $cubeShadowEl = $el.find('.swiper-cube-shadow');
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + (round * 4 * swiperSize);
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = (3 * swiperSize) + (swiperSize * 4 * round);
      }
      if (rtl) {
        tx = -tx;
      }

      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }

      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = (slideIndex * 90) + (progress * 90);
        if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);
      }
      $slideEl.transform(transform);
      if (params.slideShadows) {
        // Set shadows
        let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
    }
    $wrapperEl.css({
      '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,
      '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,
      'transform-origin': `50% 50% -${swiperSize / 2}px`,
    });

    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
        const multiplier = 1.5 - (
          (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
          + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
        );
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
      }
    }
    const zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
    $wrapperEl
      .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
  },
  setTransition(duration) {
    const swiper = this;
    const { $el, slides } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find('.swiper-cube-shadow').transition(duration);
    }
  },
};

var EffectCube = {
  name: 'effect-cube',
  params: {
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      cubeEffect: {
        setTranslate: Cube.setTranslate.bind(swiper),
        setTransition: Cube.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: false,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'cube') return;
      swiper.cubeEffect.setTransition(duration);
    },
  },
};

const Flip = {
  setTranslate() {
    const swiper = this;
    const { slides, rtlTranslate: rtl } = swiper;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let progress = $slideEl[0].progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }
      const offset = $slideEl[0].swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }

      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

      if (swiper.params.flipEffect.slideShadows) {
        // Set shadows
        let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if (shadowBefore.length === 0) {
          shadowBefore = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}"></div>`);
          $slideEl.append(shadowBefore);
        }
        if (shadowAfter.length === 0) {
          shadowAfter = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}"></div>`);
          $slideEl.append(shadowAfter);
        }
        if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
        if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
      }
      $slideEl
        .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);
    }
  },
  setTransition(duration) {
    const swiper = this;
    const { slides, activeIndex, $wrapperEl } = swiper;
    slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
    if (swiper.params.virtualTranslate && duration !== 0) {
      let eventTriggered = false;
      // eslint-disable-next-line
      slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
        eventTriggered = true;
        swiper.animating = false;
        const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
        for (let i = 0; i < triggerEvents.length; i += 1) {
          $wrapperEl.trigger(triggerEvents[i]);
        }
      });
    }
  },
};

var EffectFlip = {
  name: 'effect-flip',
  params: {
    flipEffect: {
      slideShadows: true,
      limitRotation: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      flipEffect: {
        setTranslate: Flip.setTranslate.bind(swiper),
        setTransition: Flip.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
      const overwriteParams = {
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: true,
        spaceBetween: 0,
        virtualTranslate: true,
      };
      Utils.extend(swiper.params, overwriteParams);
      Utils.extend(swiper.originalParams, overwriteParams);
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'flip') return;
      swiper.flipEffect.setTransition(duration);
    },
  },
};

const Coverflow = {
  setTranslate() {
    const swiper = this;
    const {
      width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid,
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideSize = slidesSizesGrid[i];
      const slideOffset = $slideEl[0].swiperSlideOffset;
      const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);

      let translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);
      let translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;

      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;

      $slideEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
        let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
          $slideEl.append($shadowBeforeEl);
        }
        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
          $slideEl.append($shadowAfterEl);
        }
        if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
      }
    }

    // Set correct perspective for IE10
    if (Support.pointerEvents || Support.prefixedPointerEvents) {
      const ws = $wrapperEl[0].style;
      ws.perspectiveOrigin = `${center}px 50%`;
    }
  },
  setTransition(duration) {
    const swiper = this;
    swiper.slides
      .transition(duration)
      .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
      .transition(duration);
  },
};

var EffectCoverflow = {
  name: 'effect-coverflow',
  params: {
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      modifier: 1,
      slideShadows: true,
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      coverflowEffect: {
        setTranslate: Coverflow.setTranslate.bind(swiper),
        setTransition: Coverflow.setTransition.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;

      swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);

      swiper.params.watchSlidesProgress = true;
      swiper.originalParams.watchSlidesProgress = true;
    },
    setTranslate() {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTranslate();
    },
    setTransition(duration) {
      const swiper = this;
      if (swiper.params.effect !== 'coverflow') return;
      swiper.coverflowEffect.setTransition(duration);
    },
  },
};

const Thumbs = {
  init() {
    const swiper = this;
    const { thumbs: thumbsParams } = swiper.params;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Utils.extend(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      });
      Utils.extend(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      });
    } else if (Utils.isObject(thumbsParams.swiper)) {
      swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
        watchSlidesVisibility: true,
        watchSlidesProgress: true,
        slideToClickedSlide: false,
      }));
      swiper.thumbs.swiperCreated = true;
    }
    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
  },
  onThumbClick() {
    const swiper = this;
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt(Object(__WEBPACK_IMPORTED_MODULE_0_dom7_dist_dom7_modular__["a" /* $ */])(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      let currentIndex = swiper.activeIndex;
      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix();
        // eslint-disable-next-line
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }
      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;
      else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;
      else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;
      else slideToIndex = prevIndex;
    }
    swiper.slideTo(slideToIndex);
  },
  update(initial) {
    const swiper = this;
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper) return;

    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
      ? thumbsSwiper.slidesPerViewDynamic()
      : thumbsSwiper.params.slidesPerView;

    if (swiper.realIndex !== thumbsSwiper.realIndex) {
      let currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix();
          // eslint-disable-next-line
          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        }
        // Find actual thumbs index to slide to
        const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
        const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
        if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;
        else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;
        else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;
        else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;
        else newThumbsIndex = prevThumbsIndex;
      } else {
        newThumbsIndex = swiper.realIndex;
      }
      if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex) {
          newThumbsIndex = newThumbsIndex - slidesPerView + 1;
        }
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    }

    // Activate thumbs
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }

    thumbsSwiper.slides.removeClass(thumbActiveClass);
    if (thumbsSwiper.params.loop) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
      }
    }
  },
};
var Thumbs$1 = {
  name: 'thumbs',
  params: {
    thumbs: {
      swiper: null,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-container-thumbs',
    },
  },
  create() {
    const swiper = this;
    Utils.extend(swiper, {
      thumbs: {
        swiper: null,
        init: Thumbs.init.bind(swiper),
        update: Thumbs.update.bind(swiper),
        onThumbClick: Thumbs.onThumbClick.bind(swiper),
      },
    });
  },
  on: {
    beforeInit() {
      const swiper = this;
      const { thumbs } = swiper.params;
      if (!thumbs || !thumbs.swiper) return;
      swiper.thumbs.init();
      swiper.thumbs.update(true);
    },
    slideChange() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    update() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    resize() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    observerUpdate() {
      const swiper = this;
      if (!swiper.thumbs.swiper) return;
      swiper.thumbs.update();
    },
    setTransition(duration) {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      thumbsSwiper.setTransition(duration);
    },
    beforeDestroy() {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      if (swiper.thumbs.swiperCreated && thumbsSwiper) {
        thumbsSwiper.destroy();
      }
    },
  },
};

// Swiper Class

const components = [
  Device$1,
  Support$1,
  Browser$1,
  Resize,
  Observer$1,
  Virtual$1,
  Keyboard$1,
  Mousewheel$1,
  Navigation$1,
  Pagination$1,
  Scrollbar$1,
  Parallax$1,
  Zoom$1,
  Lazy$1,
  Controller$1,
  A11y,
  History$1,
  HashNavigation$1,
  Autoplay$1,
  EffectFade,
  EffectCube,
  EffectFlip,
  EffectCoverflow,
  Thumbs$1
];

if (typeof Swiper.use === 'undefined') {
  Swiper.use = Swiper.Class.use;
  Swiper.installModule = Swiper.Class.installModule;
}

Swiper.use(components);

/* harmony default export */ __webpack_exports__["a"] = (Swiper);


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return $; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return addClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return removeClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return hasClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return toggleClass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return attr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return removeAttr; });
/* unused harmony export prop */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return data; });
/* unused harmony export removeData */
/* unused harmony export dataset */
/* unused harmony export val */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return off; });
/* unused harmony export once */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "L", function() { return trigger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return transitionEnd; });
/* unused harmony export animationEnd */
/* unused harmony export width */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return outerWidth; });
/* unused harmony export height */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return outerHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return offset; });
/* unused harmony export hide */
/* unused harmony export show */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return styles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return css; });
/* unused harmony export toArray */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return each; });
/* unused harmony export forEach */
/* unused harmony export filter */
/* unused harmony export map */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return html; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return is; });
/* unused harmony export indexOf */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return index; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return eq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return append; });
/* unused harmony export appendTo */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return prepend; });
/* unused harmony export prependTo */
/* unused harmony export insertBefore */
/* unused harmony export insertAfter */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return next; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return nextAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return prev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return prevAll; });
/* unused harmony export siblings */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return parent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return parents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return closest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return find; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return children; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return remove; });
/* unused harmony export detach */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return add; });
/* unused harmony export empty */
/* unused harmony export scrollTo */
/* unused harmony export scrollTop */
/* unused harmony export scrollLeft */
/* unused harmony export animate */
/* unused harmony export stop */
/* unused harmony export click */
/* unused harmony export blur */
/* unused harmony export focus */
/* unused harmony export focusin */
/* unused harmony export focusout */
/* unused harmony export keyup */
/* unused harmony export keydown */
/* unused harmony export keypress */
/* unused harmony export submit */
/* unused harmony export change */
/* unused harmony export mousedown */
/* unused harmony export mousemove */
/* unused harmony export mouseup */
/* unused harmony export mouseenter */
/* unused harmony export mouseleave */
/* unused harmony export mouseout */
/* unused harmony export mouseover */
/* unused harmony export touchstart */
/* unused harmony export touchend */
/* unused harmony export touchmove */
/* unused harmony export resize */
/* unused harmony export scroll */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_ssr_window__ = __webpack_require__(9);
/**
 * Dom7 2.1.3
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * http://framework7.io/docs/dom.html
 *
 * Copyright 2019, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 *
 * Licensed under MIT
 *
 * Released on: February 11, 2019
 */


class Dom7 {
  constructor(arr) {
    const self = this;
    // Create array-like object
    for (let i = 0; i < arr.length; i += 1) {
      self[i] = arr[i];
    }
    self.length = arr.length;
    // Return collection with methods
    return this;
  }
}

function $(selector, context) {
  const arr = [];
  let i = 0;
  if (selector && !context) {
    if (selector instanceof Dom7) {
      return selector;
    }
  }
  if (selector) {
      // String
    if (typeof selector === 'string') {
      let els;
      let tempParent;
      const html = selector.trim();
      if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
        let toCreate = 'div';
        if (html.indexOf('<li') === 0) toCreate = 'ul';
        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
        if (html.indexOf('<tbody') === 0) toCreate = 'table';
        if (html.indexOf('<option') === 0) toCreate = 'select';
        tempParent = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement(toCreate);
        tempParent.innerHTML = html;
        for (i = 0; i < tempParent.childNodes.length; i += 1) {
          arr.push(tempParent.childNodes[i]);
        }
      } else {
        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
          // Pure ID selector
          els = [__WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].getElementById(selector.trim().split('#')[1])];
        } else {
          // Other selectors
          els = (context || __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]).querySelectorAll(selector.trim());
        }
        for (i = 0; i < els.length; i += 1) {
          if (els[i]) arr.push(els[i]);
        }
      }
    } else if (selector.nodeType || selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */] || selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]) {
      // Node/element
      arr.push(selector);
    } else if (selector.length > 0 && selector[0].nodeType) {
      // Array of elements or instance of Dom
      for (i = 0; i < selector.length; i += 1) {
        arr.push(selector[i]);
      }
    }
  }
  return new Dom7(arr);
}

$.fn = Dom7.prototype;
$.Class = Dom7;
$.Dom7 = Dom7;

function unique(arr) {
  const uniqueArray = [];
  for (let i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());
}

function requestAnimationFrame(callback) {
  if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].requestAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].requestAnimationFrame(callback);
  else if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitRequestAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitRequestAnimationFrame(callback);
  return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].setTimeout(callback, 1000 / 60);
}
function cancelAnimationFrame(id) {
  if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cancelAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].cancelAnimationFrame(id);
  else if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitCancelAnimationFrame) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].webkitCancelAnimationFrame(id);
  return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].clearTimeout(id);
}

// Classes and attributes
function addClass(className) {
  if (typeof className === 'undefined') {
    return this;
  }
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
    }
  }
  return this;
}
function removeClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
    }
  }
  return this;
}
function hasClass(className) {
  if (!this[0]) return false;
  return this[0].classList.contains(className);
}
function toggleClass(className) {
  const classes = className.split(' ');
  for (let i = 0; i < classes.length; i += 1) {
    for (let j = 0; j < this.length; j += 1) {
      if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
    }
  }
  return this;
}
function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  }

  // Set attrs
  for (let i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      // eslint-disable-next-line
      for (const attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
// eslint-disable-next-line
function removeAttr(attr) {
  for (let i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }
  return this;
}
// eslint-disable-next-line
function prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        // eslint-disable-next-line
        for (const propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }
    return this;
  }
}
function data(key, value) {
  let el;
  if (typeof value === 'undefined') {
    el = this[0];
    // Get value
    if (el) {
      if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
        return el.dom7ElementDataStorage[key];
      }

      const dataKey = el.getAttribute(`data-${key}`);
      if (dataKey) {
        return dataKey;
      }
      return undefined;
    }
    return undefined;
  }

  // Set value
  for (let i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }
  return this;
}
function removeData(key) {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}
function dataset() {
  const el = this[0];
  if (!el) return undefined;
  const dataset = {}; // eslint-disable-line
  if (el.dataset) {
    // eslint-disable-next-line
    for (const dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (let i = 0; i < el.attributes.length; i += 1) {
      // eslint-disable-next-line
      const attr = el.attributes[i];
      if (attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
      }
    }
  }
  // eslint-disable-next-line
  for (const key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;
    else if (dataset[key] === 'true') dataset[key] = true;
    else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }
  return dataset;
}
function val(value) {
  const dom = this;
  if (typeof value === 'undefined') {
    if (dom[0]) {
      if (dom[0].multiple && dom[0].nodeName.toLowerCase() === 'select') {
        const values = [];
        for (let i = 0; i < dom[0].selectedOptions.length; i += 1) {
          values.push(dom[0].selectedOptions[i].value);
        }
        return values;
      }
      return dom[0].value;
    }
    return undefined;
  }

  for (let i = 0; i < dom.length; i += 1) {
    const el = dom[i];
    if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {
      for (let j = 0; j < el.options.length; j += 1) {
        el.options[j].selected = value.indexOf(el.options[j].value) >= 0;
      }
    } else {
      el.value = value;
    }
  }
  return dom;
}
// Transforms
// eslint-disable-next-line
function transform(transform) {
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransform = transform;
    elStyle.transform = transform;
  }
  return this;
}
function transition(duration) {
  if (typeof duration !== 'string') {
    duration = `${duration}ms`; // eslint-disable-line
  }
  for (let i = 0; i < this.length; i += 1) {
    const elStyle = this[i].style;
    elStyle.webkitTransitionDuration = duration;
    elStyle.transitionDuration = duration;
  }
  return this;
}
// Events
function on(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  function handleLiveEvent(e) {
    const target = e.target;
    if (!target) return;
    const eventData = e.target.dom7EventData || [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    if ($(target).is(targetSelector)) listener.apply(target, eventData);
    else {
      const parents = $(target).parents(); // eslint-disable-line
      for (let k = 0; k < parents.length; k += 1) {
        if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
      }
    }
  }
  function handleEvent(e) {
    const eventData = e && e.target ? e.target.dom7EventData || [] : [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    listener.apply(this, eventData);
  }
  const events = eventType.split(' ');
  let j;
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent,
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        const event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
        el.dom7LiveListeners[event].push({
          listener,
          proxyListener: handleLiveEvent,
        });
        el.addEventListener(event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off(...args) {
  let [eventType, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventType, listener, capture] = args;
    targetSelector = undefined;
  }
  if (!capture) capture = false;

  const events = eventType.split(' ');
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let handlers;
      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }
      if (handlers && handlers.length) {
        for (let k = handlers.length - 1; k >= 0; k -= 1) {
          const handler = handlers[k];
          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }
  return this;
}
function once(...args) {
  const dom = this;
  let [eventName, targetSelector, listener, capture] = args;
  if (typeof args[1] === 'function') {
    [eventName, listener, capture] = args;
    targetSelector = undefined;
  }
  function onceHandler(...eventArgs) {
    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);
    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }
  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}
function trigger(...args) {
  const events = args[0].split(' ');
  const eventData = args[1];
  for (let i = 0; i < events.length; i += 1) {
    const event = events[i];
    for (let j = 0; j < this.length; j += 1) {
      const el = this[j];
      let evt;
      try {
        evt = new __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true,
        });
      } catch (e) {
        evt = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createEvent('Event');
        evt.initEvent(event, true, true);
        evt.detail = eventData;
      }
      // eslint-disable-next-line
      el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
      el.dispatchEvent(evt);
      el.dom7EventData = [];
      delete el.dom7EventData;
    }
  }
  return this;
}
function transitionEnd(callback) {
  const events = ['webkitTransitionEnd', 'transitionend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    /* jshint validthis:true */
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
function animationEnd(callback) {
  const events = ['webkitAnimationEnd', 'animationend'];
  const dom = this;
  let i;
  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    for (i = 0; i < events.length; i += 1) {
      dom.off(events[i], fireCallBack);
    }
  }
  if (callback) {
    for (i = 0; i < events.length; i += 1) {
      dom.on(events[i], fireCallBack);
    }
  }
  return this;
}
// Sizing/Styles
function width() {
  if (this[0] === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]) {
    return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].innerWidth;
  }

  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }

  return null;
}
function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function height() {
  if (this[0] === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]) {
    return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].innerHeight;
  }

  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }

  return null;
}
function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      // eslint-disable-next-line
      const styles = this.styles();
      return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset() {
  if (this.length > 0) {
    const el = this[0];
    const box = el.getBoundingClientRect();
    const body = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */] ? __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].scrollY : el.scrollTop;
    const scrollLeft = el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */] ? __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].scrollX : el.scrollLeft;
    return {
      top: (box.top + scrollTop) - clientTop,
      left: (box.left + scrollLeft) - clientLeft,
    };
  }

  return null;
}
function hide() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }
  return this;
}
function show() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.style.display === 'none') {
      el.style.display = '';
    }
    if (__WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }
  return this;
}
function styles() {
  if (this[0]) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle(this[0], null);
  return {};
}
function css(props, value) {
  let i;
  if (arguments.length === 1) {
    if (typeof props === 'string') {
      if (this[0]) return __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i = 0; i < this.length; i += 1) {
        // eslint-disable-next-line
        for (let prop in props) {
          this[i].style[prop] = props[prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === 'string') {
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }
    return this;
  }
  return this;
}

// Dom manipulation
function toArray() {
  const arr = [];
  for (let i = 0; i < this.length; i += 1) {
    arr.push(this[i]);
  }
  return arr;
}
// Iterate over the collection passing elements to `callback`
function each(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], i, this[i]) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function forEach(callback) {
  // Don't bother continuing without a callback
  if (!callback) return this;
  // Iterate over the current collection
  for (let i = 0; i < this.length; i += 1) {
    // If the callback returns false
    if (callback.call(this[i], this[i], i) === false) {
      // End the loop early
      return this;
    }
  }
  // Return `this` to allow chained DOM operations
  return this;
}
function filter(callback) {
  const matchedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);
  }
  return new Dom7(matchedItems);
}
function map(callback) {
  const modifiedItems = [];
  const dom = this;
  for (let i = 0; i < dom.length; i += 1) {
    modifiedItems.push(callback.call(dom[i], i, dom[i]));
  }
  return new Dom7(modifiedItems);
}
// eslint-disable-next-line
function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : undefined;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }
  return this;
}
// eslint-disable-next-line
function text(text) {
  if (typeof text === 'undefined') {
    if (this[0]) {
      return this[0].textContent.trim();
    }
    return null;
  }

  for (let i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }
  return this;
}
function is(selector) {
  const el = this[0];
  let compareWith;
  let i;
  if (!el || typeof selector === 'undefined') return false;
  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);

    compareWith = $(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  } else if (selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */]) return el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */];
  else if (selector === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */]) return el === __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */];

  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  return false;
}
function indexOf(el) {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i] === el) return i;
  }
  return -1;
}
function index() {
  let child = this[0];
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
// eslint-disable-next-line
function eq(index) {
  if (typeof index === 'undefined') return this;
  const length = this.length;
  let returnIndex;
  if (index > length - 1) {
    return new Dom7([]);
  }
  if (index < 0) {
    returnIndex = length + index;
    if (returnIndex < 0) return new Dom7([]);
    return new Dom7([this[returnIndex]]);
  }
  return new Dom7([this[index]]);
}
function append(...args) {
  let newChild;

  for (let k = 0; k < args.length; k += 1) {
    newChild = args[k];
    for (let i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('div');
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (let j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }

  return this;
}
// eslint-disable-next-line
function appendTo(parent) {
  $(parent).append(this);
  return this;
}
function prepend(newChild) {
  let i;
  let j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      const tempDiv = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["a" /* document */].createElement('div');
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
// eslint-disable-next-line
function prependTo(parent) {
  $(parent).prepend(this);
  return this;
}
function insertBefore(selector) {
  const before = $(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (let j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}
function insertAfter(selector) {
  const after = $(selector);
  for (let i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (let j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return new Dom7([this[0].nextElementSibling]);
      }
      return new Dom7([]);
    }

    if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function nextAll(selector) {
  const nextEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if ($(next).is(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return new Dom7(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    const el = this[0];
    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return new Dom7([el.previousElementSibling]);
      }
      return new Dom7([]);
    }

    if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
    return new Dom7([]);
  }
  return new Dom7([]);
}
function prevAll(selector) {
  const prevEls = [];
  let el = this[0];
  if (!el) return new Dom7([]);
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if ($(prev).is(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return new Dom7(prevEls);
}
function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}
function parent(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }
  return $(unique(parents));
}
function parents(selector) {
  const parents = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    let parent = this[i].parentNode; // eslint-disable-line
    while (parent) {
      if (selector) {
        if ($(parent).is(selector)) parents.push(parent);
      } else {
        parents.push(parent);
      }
      parent = parent.parentNode;
    }
  }
  return $(unique(parents));
}
function closest(selector) {
  let closest = this; // eslint-disable-line
  if (typeof selector === 'undefined') {
    return new Dom7([]);
  }
  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }
  return closest;
}
function find(selector) {
  const foundElements = [];
  for (let i = 0; i < this.length; i += 1) {
    const found = this[i].querySelectorAll(selector);
    for (let j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return new Dom7(foundElements);
}
function children(selector) {
  const children = []; // eslint-disable-line
  for (let i = 0; i < this.length; i += 1) {
    const childNodes = this[i].childNodes;

    for (let j = 0; j < childNodes.length; j += 1) {
      if (!selector) {
        if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
      } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }
  return new Dom7(unique(children));
}
function remove() {
  for (let i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
function detach() {
  return this.remove();
}
function add(...args) {
  const dom = this;
  let i;
  let j;
  for (i = 0; i < args.length; i += 1) {
    const toAdd = $(args[i]);
    for (j = 0; j < toAdd.length; j += 1) {
      dom[dom.length] = toAdd[j];
      dom.length += 1;
    }
  }
  return dom;
}
function empty() {
  for (let i = 0; i < this.length; i += 1) {
    const el = this[i];
    if (el.nodeType === 1) {
      for (let j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }
      el.textContent = '';
    }
  }
  return this;
}

function scrollTo(...args) {
  let [left, top, duration, easing, callback] = args;
  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    [left, top, duration, callback, easing] = args;
  }
  if (typeof easing === 'undefined') easing = 'swing';

  return this.each(function animate() {
    const el = this;
    let currentTop;
    let currentLeft;
    let maxTop;
    let maxLeft;
    let newTop;
    let newLeft;
    let scrollTop; // eslint-disable-line
    let scrollLeft; // eslint-disable-line
    let animateTop = top > 0 || top === 0;
    let animateLeft = left > 0 || left === 0;
    if (typeof easing === 'undefined') {
      easing = 'swing';
    }
    if (animateTop) {
      currentTop = el.scrollTop;
      if (!duration) {
        el.scrollTop = top;
      }
    }
    if (animateLeft) {
      currentLeft = el.scrollLeft;
      if (!duration) {
        el.scrollLeft = left;
      }
    }
    if (!duration) return;
    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }
    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }
    let startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;
    function render(time = new Date().getTime()) {
      if (startTime === null) {
        startTime = time;
      }
      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      const easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));
      let done;
      if (animateTop) scrollTop = currentTop + (easeProgress * (newTop - currentTop));
      if (animateLeft) scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft));
      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }

      if (done) {
        if (callback) callback();
        return;
      }
      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  });
}
// scrollTop(top, duration, easing, callback) {
function scrollTop(...args) {
  let [top, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === 'function') {
    [top, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }
  return dom.scrollTo(undefined, top, duration, easing, callback);
}
function scrollLeft(...args) {
  let [left, duration, easing, callback] = args;
  if (args.length === 3 && typeof easing === 'function') {
    [left, duration, callback, easing] = args;
  }
  const dom = this;
  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }
  return dom.scrollTo(left, undefined, duration, easing, callback);
}

function animate(initialProps, initialParams) {
  const els = this;
  const a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: 'swing', // or 'linear'
      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */
    }, initialParams),

    elements: els,
    animating: false,
    que: [],

    easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - (Math.cos(progress * Math.PI) / 2);
      }
      if (typeof easing === 'function') {
        return easing(progress);
      }
      return progress;
    },
    stop() {
      if (a.frameId) {
        cancelAnimationFrame(a.frameId);
      }
      a.animating = false;
      a.elements.each((index, el) => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },
    done(complete) {
      a.animating = false;
      a.elements.each((index, el) => {
        const element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);
      if (a.que.length > 0) {
        const que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }
      const elements = [];

      // Define & Cache Initials & Units
      a.elements.each((index, el) => {
        let initialFullValue;
        let initialValue;
        let unit;
        let finalValue;
        let finalFullValue;

        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;

        elements[index] = {
          container: el,
        };
        Object.keys(props).forEach((prop) => {
          initialFullValue = __WEBPACK_IMPORTED_MODULE_0_ssr_window__["b" /* window */].getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue,
            initialValue,
            unit,
            finalValue,
            finalFullValue,
            currentValue: initialValue,
          };
        });
      });

      let startTime = null;
      let time;
      let elementsDone = 0;
      let propsDone = 0;
      let done;
      let began = false;

      a.animating = true;

      function render() {
        time = new Date().getTime();
        let progress;
        let easeProgress;
        // let el;
        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }
        if (startTime === null) {
          startTime = time;
        }
        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);
        }

        elements.forEach((element) => {
          const el = element;
          if (done || el.done) return;
          Object.keys(props).forEach((prop) => {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            const { initialValue, finalValue, unit } = el[prop];
            el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));
            const currentValue = el[prop].currentValue;

            if (
              (finalValue > initialValue && currentValue >= finalValue) ||
              (finalValue < initialValue && currentValue <= finalValue)) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;
              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }
              if (elementsDone === elements.length) {
                done = true;
              }
            }
            if (done) {
              a.done(params.complete);
              return;
            }
            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return;
        // Then call
        a.frameId = requestAnimationFrame(render);
      }
      a.frameId = requestAnimationFrame(render);
      return a;
    },
  };

  if (a.elements.length === 0) {
    return els;
  }

  let animateInstance;
  for (let i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }
  if (!animateInstance) {
    animateInstance = a;
  }

  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }

  return els;
}

function stop() {
  const els = this;
  for (let i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}

const noTrigger = ('resize scroll').split(' ');
function eventShortcut(name, ...args) {
  if (typeof args[0] === 'undefined') {
    for (let i = 0; i < this.length; i += 1) {
      if (noTrigger.indexOf(name) < 0) {
        if (name in this[i]) this[i][name]();
        else {
          $(this[i]).trigger(name);
        }
      }
    }
    return this;
  }
  return this.on(name, ...args);
}

function click(...args) {
  return eventShortcut.bind(this)('click', ...args);
}
function blur(...args) {
  return eventShortcut.bind(this)('blur', ...args);
}
function focus(...args) {
  return eventShortcut.bind(this)('focus', ...args);
}
function focusin(...args) {
  return eventShortcut.bind(this)('focusin', ...args);
}
function focusout(...args) {
  return eventShortcut.bind(this)('focusout', ...args);
}
function keyup(...args) {
  return eventShortcut.bind(this)('keyup', ...args);
}
function keydown(...args) {
  return eventShortcut.bind(this)('keydown', ...args);
}
function keypress(...args) {
  return eventShortcut.bind(this)('keypress', ...args);
}
function submit(...args) {
  return eventShortcut.bind(this)('submit', ...args);
}
function change(...args) {
  return eventShortcut.bind(this)('change', ...args);
}
function mousedown(...args) {
  return eventShortcut.bind(this)('mousedown', ...args);
}
function mousemove(...args) {
  return eventShortcut.bind(this)('mousemove', ...args);
}
function mouseup(...args) {
  return eventShortcut.bind(this)('mouseup', ...args);
}
function mouseenter(...args) {
  return eventShortcut.bind(this)('mouseenter', ...args);
}
function mouseleave(...args) {
  return eventShortcut.bind(this)('mouseleave', ...args);
}
function mouseout(...args) {
  return eventShortcut.bind(this)('mouseout', ...args);
}
function mouseover(...args) {
  return eventShortcut.bind(this)('mouseover', ...args);
}
function touchstart(...args) {
  return eventShortcut.bind(this)('touchstart', ...args);
}
function touchend(...args) {
  return eventShortcut.bind(this)('touchend', ...args);
}
function touchmove(...args) {
  return eventShortcut.bind(this)('touchmove', ...args);
}
function resize(...args) {
  return eventShortcut.bind(this)('resize', ...args);
}
function scroll(...args) {
  return eventShortcut.bind(this)('scroll', ...args);
}




/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "roll_container_notice",
      class: _vm.show && "roll_container_notice_click",
      on: {
        click: function($event) {
          _vm.show = !_vm.show
        }
      }
    },
    [
      _c("div", { staticClass: "roll_container_img" }, [
        _c("img", { attrs: { src: _vm.Loader, alt: "" } })
      ]),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "swiper-wrapper notice_frame" },
        _vm._l(_vm.noticeData, function(value) {
          return _c(
            "div",
            { key: value, staticClass: "swiper-slide notice_word" },
            [
              _c("a", { staticStyle: { margin: "auto 0" } }, [
                _vm._v(_vm._s(value))
              ])
            ]
          )
        }),
        0
      )
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4f859ae2", esExports)
  }
}

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_pageLabel_vue__ = __webpack_require__(10);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4e4e834a_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_pageLabel_vue__ = __webpack_require__(53);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(49)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_pageLabel_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4e4e834a_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_pageLabel_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/pageLabel/pageLabel.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4e4e834a", Component.options)
  } else {
    hotAPI.reload("data-v-4e4e834a", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(50);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("5fb7a816", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-4e4e834a\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./pageLabel.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-4e4e834a\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./pageLabel.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var escape = __webpack_require__(51);
exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.b_page_label{display:flex;height:60px;width:100%;text-align:left\n}\n.b_page_label a{font-size:22px;font-weight:bolder;margin:auto auto auto 20px\n}\n.b_page_label_avatar{height:40px;width:40px;margin:auto -10px auto 13px;border-radius:100px;overflow:hidden;background:url(" + escape(__webpack_require__(52)) + ") no-repeat 100% 100%;background-size:100%;box-shadow:0 0 10px rgba(0,0,0,0.5)\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/pageLabel/pageLabel.vue"],"names":[],"mappings":";AAAA,cAAc,aAAa,YAAY,WAAW,eAAe;CAAC;AAAA,gBAAgB,eAAe,mBAAmB,0BAA0B;CAAC;AAAA,qBAAqB,YAAY,WAAW,4BAA4B,oBAAoB,gBAAgB,6DAAiE,qBAAqB,mCAAmC;CAAC","file":"pageLabel.vue","sourcesContent":[".b_page_label{display:flex;height:60px;width:100%;text-align:left}.b_page_label a{font-size:22px;font-weight:bolder;margin:auto auto auto 20px}.b_page_label_avatar{height:40px;width:40px;margin:auto -10px auto 13px;border-radius:100px;overflow:hidden;background:url(\"../../../static/noface.png\") no-repeat 100% 100%;background-size:100%;box-shadow:0 0 10px rgba(0,0,0,0.5)}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = function escape(url) {
    if (typeof url !== 'string') {
        return url
    }
    // If url is already wrapped in quotes, remove them
    if (/^['"].*['"]$/.test(url)) {
        url = url.slice(1, -1);
    }
    // Should url be wrapped?
    // See https://drafts.csswg.org/css-values-3/#urls
    if (/["'() \t\n]/.test(url)) {
        return '"' + url.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"'
    }

    return url
}


/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "b_page_label", attrs: { id: "PageLabel" } },
    [
      _vm.avatar ? _c("div", { staticClass: "b_page_label_avatar" }) : _vm._e(),
      _vm._v(" "),
      _c("a", [_vm._t("default")], 2)
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4e4e834a", esExports)
  }
}

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tabBar_vue__ = __webpack_require__(11);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_716653cf_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tabBar_vue__ = __webpack_require__(57);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(55)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_tabBar_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_716653cf_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_tabBar_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/tabBar/tabBar.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-716653cf", Component.options)
  } else {
    hotAPI.reload("data-v-716653cf", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(56);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("50fdfb08", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-716653cf\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./tabBar.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-716653cf\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./tabBar.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.b_a{height:fit-content;width:fit-content;color:#42b983\n}\n[data-theme=\"green\"] .b_a{color:#42b983\n}\n[data-theme=\"red\"] .b_a{color:#fb7299\n}\n[data-theme=\"blue\"] .b_a{color:#1378ff\n}\n.b_a:hover{cursor:pointer;font-weight:bold\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/tabBar/tabBar.vue"],"names":[],"mappings":";AAAA,KAAK,mBAAmB,kBAAkB,aAAa;CAAC;AAAA,0BAA0B,aAAa;CAAC;AAAA,wBAAwB,aAAa;CAAC;AAAA,yBAAyB,aAAa;CAAC;AAAA,WAAW,eAAe,gBAAgB;CAAC","file":"tabBar.vue","sourcesContent":[".b_a{height:fit-content;width:fit-content;color:#42b983}[data-theme=\"green\"] .b_a{color:#42b983}[data-theme=\"red\"] .b_a{color:#fb7299}[data-theme=\"blue\"] .b_a{color:#1378ff}.b_a:hover{cursor:pointer;font-weight:bold}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      attrs: { id: "TabBar" },
      on: {
        click: function($event) {
          return _vm.hrefJump()
        }
      }
    },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-716653cf", esExports)
  }
}

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_title_vue__ = __webpack_require__(12);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_186ad4fe_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_title_vue__ = __webpack_require__(61);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(59)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_title_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_186ad4fe_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_title_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/title/title.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-186ad4fe", Component.options)
  } else {
    hotAPI.reload("data-v-186ad4fe", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(60);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("0872bd80", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-186ad4fe\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./title.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-186ad4fe\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./title.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.head_view{display:flex;height:234px;width:100%;box-shadow:0 0 30px #969696;background:#7d7d7d no-repeat center;background-size:cover;color:#42b983\n}\n[data-theme=\"green\"] .head_view{color:#42b983\n}\n[data-theme=\"red\"] .head_view{color:#fb7299\n}\n[data-theme=\"blue\"] .head_view{color:#1378ff\n}\n.head_view a{margin:auto;color:white;font-size:40px;font-weight:bolder\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/title/title.vue"],"names":[],"mappings":";AAAA,WAAW,aAAa,aAAa,WAAW,4BAA4B,oCAAoC,sBAAsB,aAAa;CAAC;AAAA,gCAAgC,aAAa;CAAC;AAAA,8BAA8B,aAAa;CAAC;AAAA,+BAA+B,aAAa;CAAC;AAAA,aAAa,YAAY,YAAY,eAAe,kBAAkB;CAAC","file":"title.vue","sourcesContent":[".head_view{display:flex;height:234px;width:100%;box-shadow:0 0 30px #969696;background:#7d7d7d no-repeat center;background-size:cover;color:#42b983}[data-theme=\"green\"] .head_view{color:#42b983}[data-theme=\"red\"] .head_view{color:#fb7299}[data-theme=\"blue\"] .head_view{color:#1378ff}.head_view a{margin:auto;color:white;font-size:40px;font-weight:bolder}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "head_view",
      style: { backgroundImage: "url(" + _vm.Img + ")" },
      attrs: { id: "photo" }
    },
    [_c("a", [_vm._v(_vm._s(_vm.title))])]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-186ad4fe", esExports)
  }
}

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_naviBar_vue__ = __webpack_require__(13);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6584a1ab_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_naviBar_vue__ = __webpack_require__(65);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(63)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_naviBar_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6584a1ab_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_naviBar_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/naviBar/naviBar.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-6584a1ab", Component.options)
  } else {
    hotAPI.reload("data-v-6584a1ab", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(64);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("71bb4780", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-6584a1ab\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./naviBar.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-6584a1ab\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./naviBar.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.occupy{height:30px\n}\n.left_bar{text-align:center;height:100%;width:100%;float:left;margin:0 auto auto auto;overflow:auto\n}\n.left_bar::-webkit-scrollbar{width:0;height:0\n}\n.div_frame{display:block;width:80%;margin:20px auto\n}\n.left_frame{display:flex;height:34px;width:100%;margin:0 auto;color:rgba(0,0,0,0.6);font-weight:bolder;border-radius:12px;border-left:3px solid rgba(0,0,0,0);border-right:3px solid rgba(0,0,0,0);background-color:rgba(0,0,0,0.08);box-shadow:0 0 3px rgba(0,0,0,0.08)\n}\n.left_frame:hover{cursor:pointer;transition:box-shadow 200ms, background-color 200ms;color:#42b983;border-left:3px solid #42b983;border-right:3px solid #42b983;background-color:white;box-shadow:0 0 3px rgba(66,185,131,0.6)\n}\n[data-theme=\"green\"] .left_frame:hover{color:#42b983\n}\n[data-theme=\"red\"] .left_frame:hover{color:#fb7299\n}\n[data-theme=\"blue\"] .left_frame:hover{color:#1378ff\n}\n[data-theme=\"green\"] .left_frame:hover{border-left:3px solid #42b983\n}\n[data-theme=\"red\"] .left_frame:hover{border-left:3px solid #fb7299\n}\n[data-theme=\"blue\"] .left_frame:hover{border-left:3px solid #1378ff\n}\n[data-theme=\"green\"] .left_frame:hover{border-right:3px solid #42b983\n}\n[data-theme=\"red\"] .left_frame:hover{border-right:3px solid #fb7299\n}\n[data-theme=\"blue\"] .left_frame:hover{border-right:3px solid #1378ff\n}\n[data-theme=\"green\"] .left_frame:hover{box-shadow:0 0 3px rgba(66,185,131,0.6)\n}\n[data-theme=\"red\"] .left_frame:hover{box-shadow:0 0 3px rgba(251,114,153,0.6)\n}\n[data-theme=\"blue\"] .left_frame:hover{box-shadow:0 0 3px rgba(19,120,255,0.6)\n}\n.left_frame a{margin:auto\n}\n.drop_off_css{border-bottom-right-radius:0;border-left:3px solid #42b983;border-right:3px solid #42b983\n}\n[data-theme=\"green\"] .drop_off_css{border-left:3px solid #42b983\n}\n[data-theme=\"red\"] .drop_off_css{border-left:3px solid #fb7299\n}\n[data-theme=\"blue\"] .drop_off_css{border-left:3px solid #1378ff\n}\n[data-theme=\"green\"] .drop_off_css{border-right:3px solid #42b983\n}\n[data-theme=\"red\"] .drop_off_css{border-right:3px solid #fb7299\n}\n[data-theme=\"blue\"] .drop_off_css{border-right:3px solid #1378ff\n}\n.left_frame_select_color{color:#42b983\n}\n[data-theme=\"green\"] .left_frame_select_color{color:#42b983\n}\n[data-theme=\"red\"] .left_frame_select_color{color:#fb7299\n}\n[data-theme=\"blue\"] .left_frame_select_color{color:#1378ff\n}\n.left_frame_drop{display:flex;width:100%;margin:0 -3px 0 auto;-webkit-margin-start:3px\n}\n.drop_paste{display:block;width:87%;margin:0 0 auto auto\n}\n.left_frame_drop_mid{display:flex;height:30px;width:100%;margin:0 0 auto auto;font-size:14px;border-right:3px solid #42b983;animation:table_navi 0.25s infinite;animation-iteration-count:1;color:rgba(0,0,0,0.6);background-color:rgba(0,0,0,0.03);overflow:hidden\n}\n[data-theme=\"green\"] .left_frame_drop_mid{border-right:3px solid #42b983\n}\n[data-theme=\"red\"] .left_frame_drop_mid{border-right:3px solid #fb7299\n}\n[data-theme=\"blue\"] .left_frame_drop_mid{border-right:3px solid #1378ff\n}\n.left_frame_drop_mid:hover{cursor:pointer;color:white;transition:box-shadow 100ms ,background-color 100ms;background-color:rgba(66,185,131,0.8)\n}\n[data-theme=\"green\"] .left_frame_drop_mid:hover{background-color:rgba(66,185,131,0.8)\n}\n[data-theme=\"red\"] .left_frame_drop_mid:hover{background-color:rgba(251,114,153,0.8)\n}\n[data-theme=\"blue\"] .left_frame_drop_mid:hover{background-color:rgba(19,120,255,0.8)\n}\n.left_frame_drop_select{display:flex;height:100%;width:100%;margin:auto\n}\n.left_frame_drop_select a{margin:auto\n}\n.left_frame_drop_select_bac{color:white;background-color:rgba(66,185,131,0.9)\n}\n[data-theme=\"green\"] .left_frame_drop_select_bac{background-color:rgba(66,185,131,0.9)\n}\n[data-theme=\"red\"] .left_frame_drop_select_bac{background-color:rgba(251,114,153,0.9)\n}\n[data-theme=\"blue\"] .left_frame_drop_select_bac{background-color:rgba(19,120,255,0.9)\n}\n.drop_last_css{border-bottom-left-radius:12px;border-bottom-right-radius:12px\n}\n.drop_select{background-color:rgba(66,185,131,0.9)\n}\n[data-theme=\"green\"] .drop_select{background-color:rgba(66,185,131,0.9)\n}\n[data-theme=\"red\"] .drop_select{background-color:rgba(251,114,153,0.9)\n}\n[data-theme=\"blue\"] .drop_select{background-color:rgba(19,120,255,0.9)\n}\n@keyframes table_navi{\nfrom{height:22px\n}\nto{height:30px\n}\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/naviBar/naviBar.vue"],"names":[],"mappings":";AAAA,QAAQ,WAAW;CAAC;AAAA,UAAU,kBAAkB,YAAY,WAAW,WAAW,wBAAwB,aAAa;CAAC;AAAA,6BAA6B,QAAQ,QAAQ;CAAC;AAAA,WAAW,cAAc,UAAU,gBAAgB;CAAC;AAAA,YAAY,aAAa,YAAY,WAAW,cAAc,sBAAsB,mBAAmB,mBAAmB,oCAAoC,qCAAqC,kCAAkC,mCAAmC;CAAC;AAAA,kBAAkB,eAAe,oDAAoD,cAAc,8BAA8B,+BAA+B,uBAAuB,uCAAuC;CAAC;AAAA,uCAAuC,aAAa;CAAC;AAAA,qCAAqC,aAAa;CAAC;AAAA,sCAAsC,aAAa;CAAC;AAAA,uCAAuC,6BAA6B;CAAC;AAAA,qCAAqC,6BAA6B;CAAC;AAAA,sCAAsC,6BAA6B;CAAC;AAAA,uCAAuC,8BAA8B;CAAC;AAAA,qCAAqC,8BAA8B;CAAC;AAAA,sCAAsC,8BAA8B;CAAC;AAAA,uCAAuC,uCAAuC;CAAC;AAAA,qCAAqC,wCAAwC;CAAC;AAAA,sCAAsC,uCAAuC;CAAC;AAAA,cAAc,WAAW;CAAC;AAAA,cAAc,6BAA6B,8BAA8B,8BAA8B;CAAC;AAAA,mCAAmC,6BAA6B;CAAC;AAAA,iCAAiC,6BAA6B;CAAC;AAAA,kCAAkC,6BAA6B;CAAC;AAAA,mCAAmC,8BAA8B;CAAC;AAAA,iCAAiC,8BAA8B;CAAC;AAAA,kCAAkC,8BAA8B;CAAC;AAAA,yBAAyB,aAAa;CAAC;AAAA,8CAA8C,aAAa;CAAC;AAAA,4CAA4C,aAAa;CAAC;AAAA,6CAA6C,aAAa;CAAC;AAAA,iBAAiB,aAAa,WAAW,qBAAqB,wBAAwB;CAAC;AAAA,YAAY,cAAc,UAAU,oBAAoB;CAAC;AAAA,qBAAqB,aAAa,YAAY,WAAW,qBAAqB,eAAe,+BAA+B,oCAAoC,4BAA4B,sBAAsB,kCAAkC,eAAe;CAAC;AAAA,0CAA0C,8BAA8B;CAAC;AAAA,wCAAwC,8BAA8B;CAAC;AAAA,yCAAyC,8BAA8B;CAAC;AAAA,2BAA2B,eAAe,YAAY,oDAAoD,qCAAqC;CAAC;AAAA,gDAAgD,qCAAqC;CAAC;AAAA,8CAA8C,sCAAsC;CAAC;AAAA,+CAA+C,qCAAqC;CAAC;AAAA,wBAAwB,aAAa,YAAY,WAAW,WAAW;CAAC;AAAA,0BAA0B,WAAW;CAAC;AAAA,4BAA4B,YAAY,qCAAqC;CAAC;AAAA,iDAAiD,qCAAqC;CAAC;AAAA,+CAA+C,sCAAsC;CAAC;AAAA,gDAAgD,qCAAqC;CAAC;AAAA,eAAe,+BAA+B,+BAA+B;CAAC;AAAA,aAAa,qCAAqC;CAAC;AAAA,kCAAkC,qCAAqC;CAAC;AAAA,gCAAgC,sCAAsC;CAAC;AAAA,iCAAiC,qCAAqC;CAAC;AAAA;AAAsB,KAAK,WAAW;CAAC;AAAA,GAAG,WAAW;CAAC;CAAC","file":"naviBar.vue","sourcesContent":[".occupy{height:30px}.left_bar{text-align:center;height:100%;width:100%;float:left;margin:0 auto auto auto;overflow:auto}.left_bar::-webkit-scrollbar{width:0;height:0}.div_frame{display:block;width:80%;margin:20px auto}.left_frame{display:flex;height:34px;width:100%;margin:0 auto;color:rgba(0,0,0,0.6);font-weight:bolder;border-radius:12px;border-left:3px solid rgba(0,0,0,0);border-right:3px solid rgba(0,0,0,0);background-color:rgba(0,0,0,0.08);box-shadow:0 0 3px rgba(0,0,0,0.08)}.left_frame:hover{cursor:pointer;transition:box-shadow 200ms, background-color 200ms;color:#42b983;border-left:3px solid #42b983;border-right:3px solid #42b983;background-color:white;box-shadow:0 0 3px rgba(66,185,131,0.6)}[data-theme=\"green\"] .left_frame:hover{color:#42b983}[data-theme=\"red\"] .left_frame:hover{color:#fb7299}[data-theme=\"blue\"] .left_frame:hover{color:#1378ff}[data-theme=\"green\"] .left_frame:hover{border-left:3px solid #42b983}[data-theme=\"red\"] .left_frame:hover{border-left:3px solid #fb7299}[data-theme=\"blue\"] .left_frame:hover{border-left:3px solid #1378ff}[data-theme=\"green\"] .left_frame:hover{border-right:3px solid #42b983}[data-theme=\"red\"] .left_frame:hover{border-right:3px solid #fb7299}[data-theme=\"blue\"] .left_frame:hover{border-right:3px solid #1378ff}[data-theme=\"green\"] .left_frame:hover{box-shadow:0 0 3px rgba(66,185,131,0.6)}[data-theme=\"red\"] .left_frame:hover{box-shadow:0 0 3px rgba(251,114,153,0.6)}[data-theme=\"blue\"] .left_frame:hover{box-shadow:0 0 3px rgba(19,120,255,0.6)}.left_frame a{margin:auto}.drop_off_css{border-bottom-right-radius:0;border-left:3px solid #42b983;border-right:3px solid #42b983}[data-theme=\"green\"] .drop_off_css{border-left:3px solid #42b983}[data-theme=\"red\"] .drop_off_css{border-left:3px solid #fb7299}[data-theme=\"blue\"] .drop_off_css{border-left:3px solid #1378ff}[data-theme=\"green\"] .drop_off_css{border-right:3px solid #42b983}[data-theme=\"red\"] .drop_off_css{border-right:3px solid #fb7299}[data-theme=\"blue\"] .drop_off_css{border-right:3px solid #1378ff}.left_frame_select_color{color:#42b983}[data-theme=\"green\"] .left_frame_select_color{color:#42b983}[data-theme=\"red\"] .left_frame_select_color{color:#fb7299}[data-theme=\"blue\"] .left_frame_select_color{color:#1378ff}.left_frame_drop{display:flex;width:100%;margin:0 -3px 0 auto;-webkit-margin-start:3px}.drop_paste{display:block;width:87%;margin:0 0 auto auto}.left_frame_drop_mid{display:flex;height:30px;width:100%;margin:0 0 auto auto;font-size:14px;border-right:3px solid #42b983;animation:table_navi 0.25s infinite;animation-iteration-count:1;color:rgba(0,0,0,0.6);background-color:rgba(0,0,0,0.03);overflow:hidden}[data-theme=\"green\"] .left_frame_drop_mid{border-right:3px solid #42b983}[data-theme=\"red\"] .left_frame_drop_mid{border-right:3px solid #fb7299}[data-theme=\"blue\"] .left_frame_drop_mid{border-right:3px solid #1378ff}.left_frame_drop_mid:hover{cursor:pointer;color:white;transition:box-shadow 100ms ,background-color 100ms;background-color:rgba(66,185,131,0.8)}[data-theme=\"green\"] .left_frame_drop_mid:hover{background-color:rgba(66,185,131,0.8)}[data-theme=\"red\"] .left_frame_drop_mid:hover{background-color:rgba(251,114,153,0.8)}[data-theme=\"blue\"] .left_frame_drop_mid:hover{background-color:rgba(19,120,255,0.8)}.left_frame_drop_select{display:flex;height:100%;width:100%;margin:auto}.left_frame_drop_select a{margin:auto}.left_frame_drop_select_bac{color:white;background-color:rgba(66,185,131,0.9)}[data-theme=\"green\"] .left_frame_drop_select_bac{background-color:rgba(66,185,131,0.9)}[data-theme=\"red\"] .left_frame_drop_select_bac{background-color:rgba(251,114,153,0.9)}[data-theme=\"blue\"] .left_frame_drop_select_bac{background-color:rgba(19,120,255,0.9)}.drop_last_css{border-bottom-left-radius:12px;border-bottom-right-radius:12px}.drop_select{background-color:rgba(66,185,131,0.9)}[data-theme=\"green\"] .drop_select{background-color:rgba(66,185,131,0.9)}[data-theme=\"red\"] .drop_select{background-color:rgba(251,114,153,0.9)}[data-theme=\"blue\"] .drop_select{background-color:rgba(19,120,255,0.9)}@keyframes table_navi{from{height:22px}to{height:30px}}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "left_bar", attrs: { id: "left" } },
    [
      _c("div", { staticClass: "occupy" }),
      _vm._v(" "),
      _vm._l(_vm.naviRouter, function(value, index) {
        return _c("div", { key: value.name, staticClass: "div_frame" }, [
          _c(
            "div",
            {
              staticClass: "left_frame",
              class: value.show_ && value.lab.length !== 0 && "drop_off_css",
              on: {
                click: function($event) {
                  value.lab.length === 0
                    ? _vm.turn(value.path, index)
                    : (value.show_ = !value.show_)
                }
              }
            },
            [
              _c(
                "a",
                {
                  class:
                    _vm.select_open[0] === index && "left_frame_select_color"
                },
                [_vm._v(_vm._s(value.name))]
              )
            ]
          ),
          _vm._v(" "),
          _c(
            "div",
            {
              directives: [
                {
                  name: "show",
                  rawName: "v-show",
                  value: value.show_,
                  expression: "value.show_"
                }
              ],
              staticClass: "left_frame_drop"
            },
            [
              _c(
                "div",
                { staticClass: "drop_paste" },
                _vm._l(value.lab, function(valueIn, indexIn) {
                  return _c(
                    "div",
                    {
                      staticClass: "left_frame_drop_mid",
                      class:
                        indexIn === value.lab.length - 1 && "drop_last_css",
                      on: {
                        click: function($event) {
                          return _vm.turn(
                            valueIn.onclick,
                            valueIn.To,
                            index,
                            indexIn
                          )
                        }
                      }
                    },
                    [
                      _c(
                        "div",
                        {
                          staticClass: "left_frame_drop_select",
                          class:
                            _vm.select_open[0] === index &&
                            _vm.select_open[1] === indexIn &&
                            "left_frame_drop_select_bac"
                        },
                        [_c("a", [_vm._v(_vm._s(valueIn.name))])]
                      )
                    ]
                  )
                }),
                0
              )
            ]
          )
        ])
      })
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-6584a1ab", esExports)
  }
}

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dot_vue__ = __webpack_require__(14);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1242a7ba_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_dot_vue__ = __webpack_require__(69);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(67)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_dot_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1242a7ba_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_dot_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/dot/dot.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1242a7ba", Component.options)
  } else {
    hotAPI.reload("data-v-1242a7ba", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(68);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("6bb633c4", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-1242a7ba\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dot.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-1242a7ba\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dot.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.b_dot{position:fixed;bottom:100px;right:30px;display:flex;height:54px;width:54px;color:white;background-color:rgba(0,0,0,0.6);box-shadow:0 0 8px rgba(0,0,0,0.4);overflow:hidden\n}\n.b_dot:hover{cursor:pointer;background-color:rgba(66,185,131,0.9);box-shadow:0 0 12px rgba(66,185,131,0.9)\n}\n[data-theme=\"green\"] .b_dot:hover{background-color:rgba(66,185,131,0.9)\n}\n[data-theme=\"red\"] .b_dot:hover{background-color:rgba(251,114,153,0.9)\n}\n[data-theme=\"blue\"] .b_dot:hover{background-color:rgba(19,120,255,0.9)\n}\n[data-theme=\"green\"] .b_dot:hover{box-shadow:0 0 12px rgba(66,185,131,0.9)\n}\n[data-theme=\"red\"] .b_dot:hover{box-shadow:0 0 12px rgba(251,114,153,0.9)\n}\n[data-theme=\"blue\"] .b_dot:hover{box-shadow:0 0 12px rgba(19,120,255,0.9)\n}\n.b_dot_white{color:#161616;background-color:white\n}\n.b_dot_white:hover{color:white\n}\n.b_dot_slot{margin:auto;font-weight:bolder;font-size:14px\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/dot/dot.vue"],"names":[],"mappings":";AAAA,OAAO,eAAe,aAAa,WAAW,aAAa,YAAY,WAAW,YAAY,iCAAiC,mCAAmC,eAAe;CAAC;AAAA,aAAa,eAAe,sCAAsC,wCAAwC;CAAC;AAAA,kCAAkC,qCAAqC;CAAC;AAAA,gCAAgC,sCAAsC;CAAC;AAAA,iCAAiC,qCAAqC;CAAC;AAAA,kCAAkC,wCAAwC;CAAC;AAAA,gCAAgC,yCAAyC;CAAC;AAAA,iCAAiC,wCAAwC;CAAC;AAAA,aAAa,cAAc,sBAAsB;CAAC;AAAA,mBAAmB,WAAW;CAAC;AAAA,YAAY,YAAY,mBAAmB,cAAc;CAAC","file":"dot.vue","sourcesContent":[".b_dot{position:fixed;bottom:100px;right:30px;display:flex;height:54px;width:54px;color:white;background-color:rgba(0,0,0,0.6);box-shadow:0 0 8px rgba(0,0,0,0.4);overflow:hidden}.b_dot:hover{cursor:pointer;background-color:rgba(66,185,131,0.9);box-shadow:0 0 12px rgba(66,185,131,0.9)}[data-theme=\"green\"] .b_dot:hover{background-color:rgba(66,185,131,0.9)}[data-theme=\"red\"] .b_dot:hover{background-color:rgba(251,114,153,0.9)}[data-theme=\"blue\"] .b_dot:hover{background-color:rgba(19,120,255,0.9)}[data-theme=\"green\"] .b_dot:hover{box-shadow:0 0 12px rgba(66,185,131,0.9)}[data-theme=\"red\"] .b_dot:hover{box-shadow:0 0 12px rgba(251,114,153,0.9)}[data-theme=\"blue\"] .b_dot:hover{box-shadow:0 0 12px rgba(19,120,255,0.9)}.b_dot_white{color:#161616;background-color:white}.b_dot_white:hover{color:white}.b_dot_slot{margin:auto;font-weight:bolder;font-size:14px}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "b_dot",
      class: _vm.backGroundColor === "white" && "b_dot_white",
      style: _vm.b_dot_style,
      attrs: { id: "Dot" },
      on: { click: _vm.callBack_ }
    },
    [_c("div", { staticClass: "b_dot_slot" }, [_vm._t("default")], 2)]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-1242a7ba", esExports)
  }
}

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_headBar_vue__ = __webpack_require__(15);
/* unused harmony namespace reexport */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_7a682692_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_headBar_vue__ = __webpack_require__(75);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(71)
}
var normalizeComponent = __webpack_require__(2)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_headBar_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_7a682692_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_headBar_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/headBar/headBar.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7a682692", Component.options)
  } else {
    hotAPI.reload("data-v-7a682692", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(72);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(1)("3225fa3a", content, false, {});
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-7a682692\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./headBar.vue", function() {
     var newContent = require("!!../../../node_modules/css-loader/index.js?sourceMap!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-7a682692\",\"scoped\":false,\"hasInlineConfig\":false}!../../../node_modules/sass-loader/dist/cjs.js!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./headBar.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(true);
// imports


// module
exports.push([module.i, "\n.b_top_bar{position:fixed;top:0;z-index:99;display:flex;height:60px;width:100%;text-align:left;box-shadow:0 0 3px #D7D7D7;transition:background-color 300ms\n}\n.label_logo{display:flex;height:100%;width:200px;margin:0 auto 0 40px\n}\n.label_logo_img{display:flex;height:45px;width:45px;margin:auto 10px auto 8px\n}\n.label_logo_img img{height:auto;width:100%;margin:auto;overflow:hidden\n}\n.label_logo a{font-size:22px;margin:auto auto auto 2px\n}\n.label_search{display:block;text-align:center;height:100%;width:190px;margin:0 0 0 auto\n}\n.label_search_frame{display:flex;height:30px;width:173px;margin:14px auto 6px 0;border-radius:100px;border:1px solid #D7D7D7\n}\n.label_search_frame:hover{border:1px solid rgba(66,185,131,0.8)\n}\n[data-theme=\"green\"] .label_search_frame:hover{border:1px solid rgba(66,185,131,0.8)\n}\n[data-theme=\"red\"] .label_search_frame:hover{border:1px solid rgba(251,114,153,0.8)\n}\n[data-theme=\"blue\"] .label_search_frame:hover{border:1px solid rgba(19,120,255,0.8)\n}\n.label_search_drop{height:180px;width:138px;margin:0 auto auto 10px;padding:8px;text-align:left;background-color:white;border-radius:4px;border:1px solid #cdcdcd;overflow:hidden\n}\n.search_img{display:flex;height:26px;width:26px;margin:auto 2px;border-radius:50px;overflow:hidden\n}\n.search_img:hover{cursor:pointer;background-color:rgba(66,185,131,0.8)\n}\n[data-theme=\"green\"] .search_img:hover{background-color:rgba(66,185,131,0.8)\n}\n[data-theme=\"red\"] .search_img:hover{background-color:rgba(251,114,153,0.8)\n}\n[data-theme=\"blue\"] .search_img:hover{background-color:rgba(19,120,255,0.8)\n}\n.search_img img{height:80%;width:80%;margin:auto\n}\n.search_label_d{display:flex;height:100%;width:130px\n}\n.search_label_d input{border:none;outline:none;width:100%;background-color:rgba(255,255,255,0)\n}\n.label_router{display:flex;height:100%;margin:0 15px 0 0\n}\n.router_frame{display:block;height:100%;margin:auto 0;color:#304455\n}\n.router_frame:hover{cursor:pointer;color:#42b983\n}\n[data-theme=\"green\"] .router_frame:hover{color:#42b983\n}\n[data-theme=\"red\"] .router_frame:hover{color:#fb7299\n}\n[data-theme=\"blue\"] .router_frame:hover{color:#1378ff\n}\n.router_title{display:flex;height:100%;padding-left:20px;padding-right:20px\n}\n.router_title a{font-size:16px;margin:auto\n}\n.theme_title{padding-left:12px;padding-right:8px\n}\n.router_border{border-bottom:3px solid rgba(66,185,131,0.8)\n}\n[data-theme=\"green\"] .router_border{border-bottom:3px solid rgba(66,185,131,0.8)\n}\n[data-theme=\"red\"] .router_border{border-bottom:3px solid rgba(251,114,153,0.8)\n}\n[data-theme=\"blue\"] .router_border{border-bottom:3px solid rgba(19,120,255,0.8)\n}\n.theme_show_div{height:20px;width:40px;margin:auto;border-radius:4px;background-color:rgba(66,185,131,0.8)\n}\n[data-theme=\"green\"] .theme_show_div{background-color:rgba(66,185,131,0.8)\n}\n[data-theme=\"red\"] .theme_show_div{background-color:rgba(251,114,153,0.8)\n}\n[data-theme=\"blue\"] .theme_show_div{background-color:rgba(19,120,255,0.8)\n}\n.drop_occupy{display:block;height:1px;width:1px;margin:-10px auto auto 0\n}\n.drop_occupy_last{float:right\n}\n.drop_frame{display:block;min-width:120px;margin:0 0 auto auto;padding:8px;background-color:white;border-radius:4px;border:1px solid #cdcdcd\n}\n.theme_drop_frame{min-width:66px\n}\n.drop_frame_title{display:flex;height:32px;width:100%;color:#595959;margin:0 auto;border-radius:3px\n}\n.drop_frame_title:hover{background-color:rgba(66,185,131,0.8);color:white\n}\n[data-theme=\"green\"] .drop_frame_title:hover{background-color:rgba(66,185,131,0.8)\n}\n[data-theme=\"red\"] .drop_frame_title:hover{background-color:rgba(251,114,153,0.8)\n}\n[data-theme=\"blue\"] .drop_frame_title:hover{background-color:rgba(19,120,255,0.8)\n}\n.drop_frame_title a{font-size:15px;margin:auto auto auto 8px\n}\n.theme_change_green:hover{background-color:rgba(66,185,131,0.8)\n}\n.theme_change_blue:hover{background-color:rgba(19,120,255,0.8)\n}\n.theme_change_red:hover{background-color:rgba(251,114,153,0.8)\n}\n", "", {"version":3,"sources":["/项目/brick-library/src/components/headBar/headBar.vue"],"names":[],"mappings":";AAAA,WAAW,eAAe,MAAM,WAAW,aAAa,YAAY,WAAW,gBAAgB,2BAA2B,iCAAiC;CAAC;AAAA,YAAY,aAAa,YAAY,YAAY,oBAAoB;CAAC;AAAA,gBAAgB,aAAa,YAAY,WAAW,yBAAyB;CAAC;AAAA,oBAAoB,YAAY,WAAW,YAAY,eAAe;CAAC;AAAA,cAAc,eAAe,yBAAyB;CAAC;AAAA,cAAc,cAAc,kBAAkB,YAAY,YAAY,iBAAiB;CAAC;AAAA,oBAAoB,aAAa,YAAY,YAAY,uBAAuB,oBAAoB,wBAAwB;CAAC;AAAA,0BAA0B,qCAAqC;CAAC;AAAA,+CAA+C,qCAAqC;CAAC;AAAA,6CAA6C,sCAAsC;CAAC;AAAA,8CAA8C,qCAAqC;CAAC;AAAA,mBAAmB,aAAa,YAAY,wBAAwB,YAAY,gBAAgB,uBAAuB,kBAAkB,yBAAyB,eAAe;CAAC;AAAA,YAAY,aAAa,YAAY,WAAW,gBAAgB,mBAAmB,eAAe;CAAC;AAAA,kBAAkB,eAAe,qCAAqC;CAAC;AAAA,uCAAuC,qCAAqC;CAAC;AAAA,qCAAqC,sCAAsC;CAAC;AAAA,sCAAsC,qCAAqC;CAAC;AAAA,gBAAgB,WAAW,UAAU,WAAW;CAAC;AAAA,gBAAgB,aAAa,YAAY,WAAW;CAAC;AAAA,sBAAsB,YAAY,aAAa,WAAW,oCAAoC;CAAC;AAAA,cAAc,aAAa,YAAY,iBAAiB;CAAC;AAAA,cAAc,cAAc,YAAY,cAAc,aAAa;CAAC;AAAA,oBAAoB,eAAe,aAAa;CAAC;AAAA,yCAAyC,aAAa;CAAC;AAAA,uCAAuC,aAAa;CAAC;AAAA,wCAAwC,aAAa;CAAC;AAAA,cAAc,aAAa,YAAY,kBAAkB,kBAAkB;CAAC;AAAA,gBAAgB,eAAe,WAAW;CAAC;AAAA,aAAa,kBAAkB,iBAAiB;CAAC;AAAA,eAAe,4CAA4C;CAAC;AAAA,oCAAoC,4CAA4C;CAAC;AAAA,kCAAkC,6CAA6C;CAAC;AAAA,mCAAmC,4CAA4C;CAAC;AAAA,gBAAgB,YAAY,WAAW,YAAY,kBAAkB,qCAAqC;CAAC;AAAA,qCAAqC,qCAAqC;CAAC;AAAA,mCAAmC,sCAAsC;CAAC;AAAA,oCAAoC,qCAAqC;CAAC;AAAA,aAAa,cAAc,WAAW,UAAU,wBAAwB;CAAC;AAAA,kBAAkB,WAAW;CAAC;AAAA,YAAY,cAAc,gBAAgB,qBAAqB,YAAY,uBAAuB,kBAAkB,wBAAwB;CAAC;AAAA,kBAAkB,cAAc;CAAC;AAAA,kBAAkB,aAAa,YAAY,WAAW,cAAc,cAAc,iBAAiB;CAAC;AAAA,wBAAwB,sCAAsC,WAAW;CAAC;AAAA,6CAA6C,qCAAqC;CAAC;AAAA,2CAA2C,sCAAsC;CAAC;AAAA,4CAA4C,qCAAqC;CAAC;AAAA,oBAAoB,eAAe,yBAAyB;CAAC;AAAA,0BAA0B,qCAAqC;CAAC;AAAA,yBAAyB,qCAAqC;CAAC;AAAA,wBAAwB,sCAAsC;CAAC","file":"headBar.vue","sourcesContent":[".b_top_bar{position:fixed;top:0;z-index:99;display:flex;height:60px;width:100%;text-align:left;box-shadow:0 0 3px #D7D7D7;transition:background-color 300ms}.label_logo{display:flex;height:100%;width:200px;margin:0 auto 0 40px}.label_logo_img{display:flex;height:45px;width:45px;margin:auto 10px auto 8px}.label_logo_img img{height:auto;width:100%;margin:auto;overflow:hidden}.label_logo a{font-size:22px;margin:auto auto auto 2px}.label_search{display:block;text-align:center;height:100%;width:190px;margin:0 0 0 auto}.label_search_frame{display:flex;height:30px;width:173px;margin:14px auto 6px 0;border-radius:100px;border:1px solid #D7D7D7}.label_search_frame:hover{border:1px solid rgba(66,185,131,0.8)}[data-theme=\"green\"] .label_search_frame:hover{border:1px solid rgba(66,185,131,0.8)}[data-theme=\"red\"] .label_search_frame:hover{border:1px solid rgba(251,114,153,0.8)}[data-theme=\"blue\"] .label_search_frame:hover{border:1px solid rgba(19,120,255,0.8)}.label_search_drop{height:180px;width:138px;margin:0 auto auto 10px;padding:8px;text-align:left;background-color:white;border-radius:4px;border:1px solid #cdcdcd;overflow:hidden}.search_img{display:flex;height:26px;width:26px;margin:auto 2px;border-radius:50px;overflow:hidden}.search_img:hover{cursor:pointer;background-color:rgba(66,185,131,0.8)}[data-theme=\"green\"] .search_img:hover{background-color:rgba(66,185,131,0.8)}[data-theme=\"red\"] .search_img:hover{background-color:rgba(251,114,153,0.8)}[data-theme=\"blue\"] .search_img:hover{background-color:rgba(19,120,255,0.8)}.search_img img{height:80%;width:80%;margin:auto}.search_label_d{display:flex;height:100%;width:130px}.search_label_d input{border:none;outline:none;width:100%;background-color:rgba(255,255,255,0)}.label_router{display:flex;height:100%;margin:0 15px 0 0}.router_frame{display:block;height:100%;margin:auto 0;color:#304455}.router_frame:hover{cursor:pointer;color:#42b983}[data-theme=\"green\"] .router_frame:hover{color:#42b983}[data-theme=\"red\"] .router_frame:hover{color:#fb7299}[data-theme=\"blue\"] .router_frame:hover{color:#1378ff}.router_title{display:flex;height:100%;padding-left:20px;padding-right:20px}.router_title a{font-size:16px;margin:auto}.theme_title{padding-left:12px;padding-right:8px}.router_border{border-bottom:3px solid rgba(66,185,131,0.8)}[data-theme=\"green\"] .router_border{border-bottom:3px solid rgba(66,185,131,0.8)}[data-theme=\"red\"] .router_border{border-bottom:3px solid rgba(251,114,153,0.8)}[data-theme=\"blue\"] .router_border{border-bottom:3px solid rgba(19,120,255,0.8)}.theme_show_div{height:20px;width:40px;margin:auto;border-radius:4px;background-color:rgba(66,185,131,0.8)}[data-theme=\"green\"] .theme_show_div{background-color:rgba(66,185,131,0.8)}[data-theme=\"red\"] .theme_show_div{background-color:rgba(251,114,153,0.8)}[data-theme=\"blue\"] .theme_show_div{background-color:rgba(19,120,255,0.8)}.drop_occupy{display:block;height:1px;width:1px;margin:-10px auto auto 0}.drop_occupy_last{float:right}.drop_frame{display:block;min-width:120px;margin:0 0 auto auto;padding:8px;background-color:white;border-radius:4px;border:1px solid #cdcdcd}.theme_drop_frame{min-width:66px}.drop_frame_title{display:flex;height:32px;width:100%;color:#595959;margin:0 auto;border-radius:3px}.drop_frame_title:hover{background-color:rgba(66,185,131,0.8);color:white}[data-theme=\"green\"] .drop_frame_title:hover{background-color:rgba(66,185,131,0.8)}[data-theme=\"red\"] .drop_frame_title:hover{background-color:rgba(251,114,153,0.8)}[data-theme=\"blue\"] .drop_frame_title:hover{background-color:rgba(19,120,255,0.8)}.drop_frame_title a{font-size:15px;margin:auto auto auto 8px}.theme_change_green:hover{background-color:rgba(66,185,131,0.8)}.theme_change_blue:hover{background-color:rgba(19,120,255,0.8)}.theme_change_red:hover{background-color:rgba(251,114,153,0.8)}\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAX10lEQVR4Xu1dCfRv13jd29ASMRYxz0PEGImIGmKKKJKaqiKIIUFqFkVIJIJSQ4USlGCRNKmxxFCKxBBDTUVC1TzELIhZ1e7aet7yz8t7L7/v3OHce3/ft9ZvvWjPd4Z9zv7fe883ESmJQCKwVQSY2CQCicDWEUiC5OlIBLaBQBIkj0cikATJM5AI1CGQT5A63FJrTRBIgqzJRucy6xBIgtThllprgkASZE02OpdZh0ASpA631FoTBJIga7LRucw6BJIgdbil1pogkARZk43OZdYhkASpwy211gSBJMiabHQusw6BJEgdbqm1JggkQdZko3OZdQgkQepwS601QSAJsiYbncusQyAJUodbaq0JAkmQNdnoXGYdAkmQOtxSa00QSIKsyUbnMusQSILU4dZJS9L1AOwA4Pxb+Z0LwK+28juD5Mc6TSCVV0YgCbIyVPGGkkwCk+G6G/7dCcD54r2dReN/AXwRwGcBfGbTj+TXOvab6pshkATp8UhIugyA2wC4VfldqcfuV+nqhwBOBvBe/0h+YRWlbLN1BJIgHU6HpO0B3KGQYg8A1+zQ3RCq3wPwHgAnAXg7yW8PMciS+0yCBHdX0gUA3BnAPQDsBeBPg120ai4AHwTwWv9Ifr/VROY0bhJkhd2StB2AvQsp/MTo+g2xwqiDNvk9gA8A+BcAryPpV7OULSCQBNnGsZB0EQAHA3g4gAsv9AT9DsBxAJ5G8ksLXWP1spIgW4BO0iUA/C2AgwD4O2MdxE8VP1Gekh/3f9zuJMiGoy/p0gCeAODAYp9YB2JsvkZ/q7wJwBEkfY281pIEASDJH9qHAHj8Ar4v+jzQrwbwWJI/6LPTOfW19gSRtA+AowBceU4bN+JcfwrgyQBeRNIGyrWStSWIpCsCeGm5ql2rTa9c7OcAHEDyw5X6s1RbS4JIOgzAkY13zK4i3wDwSwC/KL9N/+2bJV8O2ObiK2b/69/FAezceN7HAHgMyTMbz2OU4deKIJIuX25qbjIKuv8/iA+SDXSnlt/nSH6iy/iSdgRwLQDXB3BtADcF4AuGscQ+X39F8uNjDdhqnLUhiCQb+I4FcNGBwf4NgFMAvLu4eXycpK9QBxVJ1wCwJ4DbFj+woe02/wPgSQCeQ9I3X4uUtSCIpBcB+JuBd9A3PsfbWZDkrwce6xy7l+Snit1h7gvABs+h5J0A7r1Ua/yiCVJeqd5aXM2HOCDvB/AaACeQ/PkQA/TRp6S/BrAvgL/so78t9GG/rruQ/NBA/TfrdrEEKe/p9mS1C3rf8nwAzyP59b47HrI/SX69fDCAxw3wqukAL5PET5TFyCIJIuk6JS7iz3rcKT8hji7v3LM2nElyJKNfOR8L4FI9YuTbt31Jvr7HPpt2tTiClHfvdwC4YE/I+hbKT4yjSJ7RU5+T6UaSiXJoz7dgDyFpG9PsZVEEkeRbnBN7itGw1fjlvqkh+aPZ7/Q2FlDc+f3aZQdN2136kENIPrOPjlr2sRiClGvct/UE5rsAPIrk53vqbxbdlJDhZ5Sbrz7mfCTJw/voqFUfiyBIea2yMa6rOETV7hS++VpbkbQLgFcB8LdcV3kYSV+zz1JmTxBJzhLykR6+Od4H4O5Lvc+Pnk5Jjpq0W8m9orqbtbcR8V4kT+jYTxP1WRNEkj1wTY5LdkDPG+jXisPGsHh3mGcTVUm+Fn4BgD/pMAF/z/0FyX/v0EcT1dkSpET92afJ/lW1Ylfuu5G0vSRlKwhIugEAv3ZetgNI9i649dy8gWdJkPL4/2hHC7k9aW+TcdirHfnyB+nfANxwNY0ttvIfpJ1JfrVDH6OqzpUgvmN/UAek/tOOffm9EUOwGBjfUhwiY8p/bG3sdyNpZ8fJy+wIUiIA39wBWXvZ7kPSrhEpQQQkOW+wHTP3C6pubG6j66M76I+mOiuClI/yT3e4sTqW5H1GQ3fBA0l6VjEs1q5y7zlcp8+GIJLOA8ABOg4SqhG/Gtx5ybELNaB00ZFkT4MHVvbxE9tZSJ5eqT+K2pwI4sQKj6xExXHUvkFpHqdROf/Jqkl6o714Kyd4CsmbVeqOojYLgkjaFUBtTQxnOL8xSd+gpPSMgKTzlpDi3Sq7PojkSyp1B1ebC0H83eE6G1FxNvNdSX4nqpjtV0dAksN7fe1ek93+xwCuQtKvXJOTyRNEkt9x/a4bFV8j7pLZAaOw1bUvaZScibEmzODFJIcOia5a2KQJUupv2KjkdDdReTjJF0aVsn09Ah2u4O3uYwOi3xQmJVMniAOVHlGB2IkknTExZWQEJNlvy9nwo/JRkrtHlYZuP1mCSHK+J+eSioqfONcn+bOoYrbvBwFJnwJg/62oOFx3Ul6/UyaI45rvFkW4kMOFLVMaISDJtRkdbBYtNPQlkldvNO0tDjtJgkhy1sDTAETn9wyST5wSwOs6F0l2JfmHivXvT9KuLJOQ6AEcZdKSXMjFSc8i4lerHUn+NqKUbYdBoPhs2THRJbAj4pzF15yKx8PkCCLpqqUGeHRutyTpqMCUiSBQQndt4I3u5X1JOiFfc4lOfPAJS3K9vGiY5/EkozqDryUH+ENxIl+1PzSIxWSeIpMiSHl61BSS3CHLGgeP4EjNJV0IwLcqDIj7kfznkaa51WGmRpCnlYzhEVwma4WNLGLJbSU9HUD08uR9JG/ZGpepEcSuz5Fcuk51eVWSDp9NmSgCkuwJ4T1yytNVxdb1K5D006eZTIYgkm4OwNnSI/Iakk7vnzJxBCT9I4CHBafZPDvjlAgSjTP3X5hrZNKF4JFr1LyU2PZTxIFvq8ppJPtIXrfqeGdrNyWC2O05UujlLSSHqndRDWgqbh0BSa7wFY1lv0FLJ8ZJEETSXQG8IXi47krSBe9TZoKAJJeHiyaPey5Jl2loIlMhyGtdFDKAwI9JXizQPptOBAFJDl6L1CQ5neTlWk1/KgRxcRqXOV5VXkLyoFUbZ7vpICDpOQAODs5op1aZ9psTpLgjRMsJ33SJ9fCCh2aWzSU5K419tCLSLEP8FAjiwi1/H0DrqySvEmifTSeGgCR7ajsr/6ryRpI1oQ+r9r/VdlMgiPO97hVYSdOPtsA8s+lWEJD01FL2bVWMziDZZ73JVccNe1mu3PEqDSWdG8AvgiXTnEbfpEqZKQKS9ihFViMrcMx69NUs0v8W2zZ9glRYz11nYruM+ei87007KH8YfTETiTg8mGRNAFantbYmSPT742SSt+q04lSeBAKSXIn49oHJvJ5kxBQQ6HrrTVsT5JUA7hdYyaEk7RmaMnMEJNn49+zAMk4lGY1ODHS/5aatCfIhADcJrCKvdwNgTblpTTpZkqOf19EH3LhpkpyaZ/vARm5P0h/1KTNHQJJrHv4muIwrk/xaUKdT82YEKTECPwjM/vskdwi0z6YTR0BSNP5nL5KuYT+atCTInwM4JbDSD5J0zEjKQhCQdBKASNTg6OlkWxLk/gBeEdjrY0geEGifTSeOgKRoDNALSdakNa1GoiVBjgBweGDmjyMZufUIdJ1NWyBQkVxu9BiglgR5LoDHBDbG9cxdzShlIQhIcsDbvwaWM7odrCVB/gnAgQFw0sUkANYcmlZ4UnyS5C5jrq0lQZzzaN/AYl1j0B91KQtBQJKrhkVqgnyR5DXGXH5Lgrjq7N6Bxd6MZOTWK9B1Nm2BQKlKFbFrfI9kJBqx87JaEuS9ACJ+VTciGQ2s6gxQdjAcAqW2YaQ24S9JRiJPO0++JUH+A8CNAiu4XtYbDKA1g6aSfP5+H5zqucbM/N6SIPbtd/jlquKi845ES1kQApLODObtvSBJu8qPIi0JEnVU3J2kSw2nLAgBSY7xOVdgSWvzBLFPzZ4BYPYk+e5A+2w6cQQkOWDqV4Fp/orkdoH2nZu2fILY6HeXwAruQjJiVAp0nU1bICDpEgC+Hxh7dIfVlgRxHbr7BMCZTNWhwJyz6TYQqKgH8xWSrkA2mrQkyNEAIsnfHkrSOikLQUCSS0W7ZPSq8mmSNeWlV+3/bO1aEsS5sByTvqo8keQzVm2c7aaPgCTbwWwPW1VGD3loSZBDATg/0qryCpIPXLVxtps+ApLsi2efvFXlbSTvtGrjPtq1JIi/PyL1sD9M0kFWKQtBQJLT+Lie+qpyNMloQdBV+95iu5YEsRXd1vRV5UySF161cbabPgIVqX8eQdKVqkaTlgS5IABbUSNySZKROPZI39l2ZAQkfRXAlQLD3o5ktL5IoPuzN21GEE9F0rcBXDqwgluQ/ECgfTadKAKSzgvgt8HpXX7sop6tCfIeALcOgJRXvQGwptxU0m4AIq5DPyfpt45RpTVBoraQJuknR92RNRlM0uMBPDOw3E+Q3DXQvpemrQniG4kXBlbyI5KuuZ0ycwQkRctevJrk/mMvuzVBaqoNZVzI2Kek5/Eqy14cSPLlPU/lHLtrSpDyoR6NBxj9qu8cUcwGIQQk3RTAB0NKwNVJfimo07n5FAhiD91IvfM3kXTZ6JSZIiDpMABHBqb/XZKR285A19tuOgWC2JIaKYziaLKLk4wmPu4NtOyoGwKSnFsgkr7nOJL37jZqnfYUCLIzgE8Gp38vkscHdbL5BBCQdE0A/xWcSpPvD89xCgTxHH4ajEt+O8k7BkHO5hNAQNLfATgkOJUm3x+TIEj5UI9GF1ot3U6Cp2wKzSV9C8BlA3P5JskrBNr32rT5E6QQxB/dbwiu7JEkXxDUyeYNEZDkUgfR7JhPJ+nQiCYyCYIUkvwQQKQW9ujRZU12aEGDSoqGWXv1VyP55VYwTIkgzwfwiCAQdyT59qBONm+AgKTLA/gKgPMEhv8QSdtMmsmUCBKNTzZoo2f7brZTMx9YkosluWhSRB5MMhJxGOl7pbaTIUh5zYpmW7RalkVYaavbNap8evzar9wkf9lu5hO45t24eEmPBHBUEJB8igQBG7t55dPjBJKR8hiDLGtqT5CLAPhmsDS0gbkDyXcMglB22gkBSVcD8MWKTvYg+f4KvV5VJkWQ8poVTQdkNTuxXYvk73pFJzvrjIAkp4u9TbCjybwVTJEgjvdw/WwXmo9IFvmMoDVCW0n7AHhzxVB7k3xrhV7vKpMjSHmKvBjAQ4Kr9cfcVUl+N6iXzQdAQJL/wPnJ7uvdiJxG8joRhSHbTpUgVyx35pG0+MbpWJKRfL9DYrvWfUt6MoCnVICwL8kTKvQGUZkkQcpT5FgA+1Ws+pYk31ehlyo9IVCRlHrTyF8m6Y/6yciUCeJqpl+oQMrfL9cn+aMK3VTpAQFJDl9wGENU9iPp6seTkckSpDxFalyjrXoSyUg6oclsyNwnIumlAB5UsY6TSUaKulYMEVeZOkFqP/SMxJNJRpJjx9FLjbMgIOluAF5fAYuv5x3zESkJXTFMXGXSBClPkdsDqDECunrqzUm6FmLKwAiU747PAKgpkfZUkv6on5xMniCFJDUBVVb1d8huJO1FmjIQApIuVhKR11R/cn7eHUlG05AOtJqzdjsXglwOwH8DOH8FKt9wPXaSkVp4FcOsp4okPzGcwqfmo9ygTfrWcRYEKU+RAwC8rPIYngrgxq09QyvnPlk1SbZTOdt67YXIS0lGDcKj4jEbghSSOJPJPSsRcqkvp893Xe6UHhCQ9BoAtel4PgfghlNP3zQ3glwAwKftUlK5v5l0rhK4zdUkRROPb+zCtdFtq6rx8u1pBat1MyuClKeI8/m6MlXUmXETIh8uTxInoEsJIlB8rF4bzIa5+Sj3IPm64NBNms+OIIUkDwPQpRTXaXbBJvm9JqjPdFBJFwLgrOw36bCEV5J8QAf9UVVnSZBCEv8FunsHtOySsifJz3foY21UJfkm8Z0Aduqw6M+Wa3eH085C5kwQl/ByxNnuHZD2a9YD5vK477DOTqqS9gJwXDAt0+ZjutzeznO7bp8tQcpTxCG6H3PupE4nALDn8EEk87tkA5Dle8OJxbuWXv4ZgF1J2pY1K5k1QQpJnJbSH+07dETefkD3JBmpm9dxyOmqS9oRgD0YrtVxlvazsjHwlI79NFGfPUEKSZxTyxtQ4we0OfCOiT+C5Gzek/s+OZKeBOBpPfU7ORf2yLoWQZBCEr8n+4alD/l6eeWqcZLsY/wmfUi6WfFW8NOjDzmU5NP76KhVH4shSCHJLQA42L+vcsF23X740uPcJTknsr817tvTQRSAJ5B8Vk/9NetmUQQpJHHA/7sA9FWyyx+Yz3NCO5I/brZTAwwsyX9IHgzgiQAu2uMQ+5N0ourZy+IIUkji+hPvAeBqRn2JifIi/6Ul+YO+Om3RjyTf/j2qJAvvkxjOLLMPSWO/CFkkQQpJLlxyMu0xwE65tvuzSdqVfjYiyX84XBPyoJ4uNDZfu+0czq+8GFksQTbtkCTX1n7gQDvmYjBOMnA8yV8MNEanbiU5huYeAJwOKZrhMDp2s1qC0Ymu2n7xBClPkwMBDJlG31fCLmdtPyN//zQXSbctpLA7Th/X36uuaVFPkbUgSCGJbSVOgzl0vTu7cjvCzjlp/fsUSd/qDCaSvI9en0nhp8TNRybFxrX5ityu7C7MOntZG4IUkviD1Fn7bjfizvnmy0ZMJzRwkNCpJB3TUi2S7PJ/7eI46P92FaY+P7ar51YU30XSdqnZy1oRZNNuSXJRyNYpgZwUzxVf/e3i25+N/9o9w1ewDhDz65H/9c8etX0Z8YY+vE8hecTQgwzd/1oSpDxNnP/XSc4W8Zdu6INS0b9fK/ci6Zj12craEmTD08Qp+l1A9Eqz3cXpTvwn5XtkVtfhG+Fce4KUp8n5ABzibIzTPWtNZmYPAnsm7Nlh9MkUw6lZQxJkA2qSLlWsy3a/cDK0dZU3AHisU4GWpHC+YLCRsVZmW5YiCbKFLS/GtfsBOLhDBpXaw9RS75UAjib58Y2TkLQLgLP83yomeQDJYyr0mqokQc4Bfkl3Kn5LQ1uhWx0Ex+Tbdea4bdkuJDljuy81usjsjIhJkBW3W5JvvfxU2R/AlVdUm2oz22ZsD3oVSUdjriQdE8V5jNkZEZMgKx2NPzYqVmvHndy/ZFWxfWIO4oySdoN5ld1iapJFlxh15wC4XocFz8qImATpsNOStgfg8gzOTWs3j6t36G4IVef9skOlfyeS/E7XQST56fkpAPaWrhWHNNfUL6wdr1ovCVIN3dkVJV2mkMWEcbWksW0rLvdwciHEe4fK+SXJ177OkVV7fmZjRKxdYI/HarldlStSP1X8c2qijf9d6ztll5QvA3BeW5dZ9r9/+G+Szj01ikiyq45ddmplFkbEJEjt9nbUK3U1bGvxz2RxXPim/31uAGeUn58K/qj+w/8m6cjGSYgkf9Ms2oiYBJnEUZvnJHoyIh5D0rVfJilJkEluy3wmJemGAD4CwKlga+XeJJ3adHKSBJnclsxvQj0YEX9TyuQ5ufWkJAkyqe2Y72SWakRMgsz3TE5q5ks1IiZBJnXM5j0ZSY73dzix827VyqSMiEmQ2m1MvS0isDQjYhIkD3rvCEg6EsBhHTqejBExCdJhF1N16whIsitKl+wxDtLahaQTWDSTJEgz6Jc9sCQ7M7pYapdIxJeTdNK/ZpIEaQb98gdeghExCbL8c9p0hZK6pn1takRMgjQ9Pusx+JyNiEmQ9TijTVc5ZyNiEqTp0VmfwXsyIh5O0lfIo0kSZDSoc6A5GhGTIHluR0VAkmPRu2SwtBHx2mNFTyZBRj0eOZgR6MGI+AkAu49hREyC5JkdHYFiRLRTo3ON1crLSDqZ3aCSBBkU3ux8awhIui4APwkmHYmYBMkz3AwBSY5Ff1mHCQxuREyCdNidVO2OQA9GxK8AuC5JV+nqXZIgvUOaHUYQ6MmI+GiSR0XGXbVtEmRVpLLdYAiUxOD+aK9NZ3oSSWez7F2SIL1Dmh3WICDJsSOOIamR75K8dI3iOekkQc4Jofz/j4aApMMB1FTGPZ2kKwD3LkmQ3iHNDrsgUGlEdKLuQQocJUG67Gbq9o5ApRExP9J734nscLIISNoZwCdXnODpAHYieeaK7UPN8gkSgisbj4WAJBckejOA7bYxpjPf337zoqN9zjEJ0iea2VevCEhyqbcTATgh3eZyrGvbk/xWr4Nu1lkSZEh0s+9eEJB091LizhlSnEn+LSRHSXSdBOllC7OTpSKQBFnqzua6ekHg/wB2YKojmnm3XQAAAABJRU5ErkJggg=="

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,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"

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "b_top_bar",
      style: _vm.head_bac,
      attrs: { id: "PageLabel" },
      on: {
        mouseover: function($event) {
          return _vm.bac_("in")
        },
        mouseout: function($event) {
          return _vm.bac_("out")
        }
      }
    },
    [
      _c("div", { staticClass: "label_logo" }, [
        _c("div", { staticClass: "label_logo_img" }, [
          _c("img", { attrs: { src: _vm.logo, alt: "" } })
        ]),
        _vm._v(" "),
        _c("a", [_vm._v(_vm._s(_vm.name))])
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "label_search" }, [
        _c("div", { staticClass: "label_search_frame" }, [
          _c(
            "div",
            {
              staticClass: "search_img",
              on: {
                click: _vm.searchButton,
                mouseover: function($event) {
                  return _vm.changeSearchImg("in")
                },
                mouseout: function($event) {
                  return _vm.changeSearchImg("out")
                }
              }
            },
            [
              _c("img", {
                attrs: { src: _vm.search_img, alt: "", draggable: "false" }
              })
            ]
          ),
          _vm._v(" "),
          _c("label", { staticClass: "search_label_d" }, [
            _c("input", {
              on: {
                input: function($event) {
                  return _vm.searchCon($event)
                },
                keyup: function($event) {
                  if (
                    !$event.type.indexOf("key") &&
                    _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                  ) {
                    return null
                  }
                  return _vm.searchButton($event)
                }
              }
            })
          ])
        ]),
        _vm._v(" "),
        _vm.search_drop_show
          ? _c(
              "div",
              {
                staticClass: "label_search_drop",
                on: {
                  mouseover: function($event) {
                    return _vm.search_drop("in")
                  },
                  mouseout: function($event) {
                    return _vm.search_drop("out")
                  }
                }
              },
              [_vm._t("default")],
              2
            )
          : _vm._e()
      ]),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "label_router" },
        [
          _vm._l(_vm.router, function(value, index) {
            return _c(
              "div",
              {
                staticClass: "router_frame",
                on: {
                  click: function($event) {},
                  mouseover: function($event) {
                    value.show_ = !value.show_
                  },
                  mouseout: function($event) {
                    value.show_ = !value.show_
                  }
                }
              },
              [
                _c("div", { staticClass: "router_title" }, [
                  _c("a", { class: value.show_ && "router_border" }, [
                    _vm._v(_vm._s(value.name))
                  ])
                ]),
                _vm._v(" "),
                _c(
                  "div",
                  {
                    staticClass: "drop_occupy",
                    class:
                      !_vm.themeConfig &&
                      index === _vm.router.length - 1 &&
                      "drop_occupy_last"
                  },
                  [
                    _c(
                      "div",
                      {
                        directives: [
                          {
                            name: "show",
                            rawName: "v-show",
                            value: value.lab.length !== 0 && value.show_,
                            expression: "value.lab.length !== 0 && value.show_"
                          }
                        ],
                        staticClass: "drop_frame",
                        class:
                          !_vm.themeConfig &&
                          index === _vm.router.length - 1 &&
                          "drop_occupy_last"
                      },
                      _vm._l(value.lab, function(valueIn, indexIn) {
                        return _c(
                          "div",
                          {
                            staticClass: "drop_frame_title",
                            on: {
                              click: function($event) {
                                return _vm.userClick(
                                  valueIn.onclick,
                                  valueIn.To
                                )
                              }
                            }
                          },
                          [_c("a", [_vm._v(_vm._s(valueIn.name))])]
                        )
                      }),
                      0
                    )
                  ]
                )
              ]
            )
          }),
          _vm._v(" "),
          _vm.themeConfig
            ? _c(
                "div",
                {
                  staticClass: "router_frame",
                  on: {
                    mouseover: function($event) {
                      _vm.theme_show = !_vm.theme_show
                    },
                    mouseout: function($event) {
                      _vm.theme_show = !_vm.theme_show
                    }
                  }
                },
                [
                  _vm._m(0),
                  _vm._v(" "),
                  _c(
                    "div",
                    { staticClass: "drop_occupy", class: "drop_occupy_last" },
                    [
                      _c(
                        "div",
                        {
                          directives: [
                            {
                              name: "show",
                              rawName: "v-show",
                              value: _vm.theme_show,
                              expression: "theme_show"
                            }
                          ],
                          staticClass: "drop_frame theme_drop_frame",
                          class: "drop_occupy_last"
                        },
                        [
                          _c(
                            "div",
                            {
                              staticClass:
                                "drop_frame_title theme_change_green",
                              on: {
                                click: function($event) {
                                  return _vm.themeFun("green")
                                }
                              }
                            },
                            [_c("a", [_vm._v("绿色")])]
                          ),
                          _vm._v(" "),
                          _c(
                            "div",
                            {
                              staticClass: "drop_frame_title theme_change_blue",
                              on: {
                                click: function($event) {
                                  return _vm.themeFun("blue")
                                }
                              }
                            },
                            [_c("a", [_vm._v("蓝色")])]
                          ),
                          _vm._v(" "),
                          _c(
                            "div",
                            {
                              staticClass: "drop_frame_title theme_change_red",
                              on: {
                                click: function($event) {
                                  return _vm.themeFun("red")
                                }
                              }
                            },
                            [_c("a", [_vm._v("粉色")])]
                          )
                        ]
                      )
                    ]
                  )
                ]
              )
            : _vm._e()
        ],
        2
      )
    ]
  )
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "router_title theme_title" }, [
      _c("div", { staticClass: "theme_show_div" })
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7a682692", esExports)
  }
}

/***/ })
/******/ ]);
});
//# sourceMappingURL=brick-library.min.js.map